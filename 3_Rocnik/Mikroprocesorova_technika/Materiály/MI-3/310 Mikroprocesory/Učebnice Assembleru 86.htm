<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0072)http://school.lynn.cz/addons/assembler/ucebnice.html -->
<HTML><HEAD><TITLE>Uèebnice Assembleru 86</TITLE>
<META name=Author content="Mgr. Tomáš Papoušek">
<META content="text/html; charset=windows-1250" http-equiv=Content-Type>
<META name=GENERATOR content="MSHTML 8.00.6001.19222"></HEAD>
<BODY link=#0000ff bgColor=#ffffff vLink=#0000ff><!--MYCHARSET=CP1250-->
<H1>Uèebnice Assembleru 86 
</H1>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Tato uèebnice mìla bıt 
pùvodnì vydána jako skripta pro školu, na které uèím. Protoe však došlo k mnoha 
objektivním problémùm (prostì nebyly peníze), nabízím je touto cestou všem, 
kteøí programují v Turbo Pascalu. I kdy v souèasné dobì pøevánì programuji v 
Delphi, znalosti z této uèebnice vyuívám. Pokud budete informace z tohoto 
dokumentu nìkdo pouívat, èiòte tak prosím s poznámkou o autorovi (copyright 
najdete na konci textu).</FONT></P>
<H3><FONT face="Arial CE, Arial, Helvetica">Obsah:</FONT></H3>
<UL>
  <LI><A 
  "%DAvodem"><FONT 
  size=-1 face="Arial CE, Arial, Helvetica">Úvodem</FONT></A> 
  <LI><A 
  "Terminologie"><FONT 
  size=-1 face="Arial CE, Arial, Helvetica">Terminologie</FONT></A><FONT size=2 
  face=Arial> </FONT>
  <LI><A 
  "Program%E1torsk%FD+model+mikroprocesoru+8086"><FONT 
  size=2 face=Arial>Programátorskı model mikroprocesoru 8086</FONT></A><FONT 
  size=-1 face="Arial CE, Arial, Helvetica"> </FONT>
  <UL>
    <LI><A 
    "Segmentace+pam%ECti"><FONT 
    size=2 face=Arial>Segmentace pamìti</FONT></A> </LI></UL>
  <LI><A 
  "Vkl%E1dan%FD+assembler+v+jazyce+Turbo+Pascal"><FONT 
  size=2 face=Arial>Vkládanı assembler v jazyce Turbo Pascal</FONT></A><FONT 
  size=-1 face="Arial CE, Arial, Helvetica"> </FONT>
  <LI><A 
  "Instrukce+p%F8esun%F9+dat"><FONT 
  size=2 face=Arial>Instrukce pøesunù dat</FONT></A><FONT size=2 face=Arial> 
  </FONT>
  <UL>
    <LI><A 
    "P%F8esuny+registr+-+registr,+registr+-+pam%EC%9D"><FONT 
    size=2 face=Arial>Pøesuny registr - registr, registr - pamì</FONT></A><FONT 
    size=2 face=Arial> </FONT>
    <LI><A 
    "Metody%20adresace"><FONT 
    size=2 face=Arial>Metody adresace</FONT></A><FONT size=2 face=Arial> </FONT>
    <LI><A 
    "Prefix+p%F8esko%E8en%ED"><FONT 
    size=2 face=Arial>Prefix pøeskoèení</FONT></A><FONT size=2 face=Arial> 
    </FONT>
    <LI><A 
    "Pr%E1ce+se+z%E1sobn%EDkem"><FONT 
    size=2 face=Arial>Práce se zásobníkem</FONT></A><FONT size=2 face=Arial> 
    </FONT>
    <LI><A 
    "P%F8esuny+vstup-v%FDstup+-+registr"><FONT 
    size=2 face=Arial>Pøesuny vstup-vıstup - registr</FONT></A><FONT size=-1 
    face="Arial CE, Arial, Helvetica"> </FONT>
    <LI><A 
    "Dal%9A%ED+p%F8esuny"><FONT 
    size=2 face=Arial>Další pøesuny</FONT></A><FONT size=2 face=Arial> 
    </FONT></LI></UL>
  <LI><A 
  "Instrukce+dosazen%ED+adresy"><FONT 
  size=2 face=Arial>Instrukce dosazení adresy</FONT></A><FONT size=2 face=Arial> 
  </FONT>
  <UL>
    <LI><A 
    "Ukazatel"><FONT 
    size=-1 face="Arial CE, Arial, Helvetica">Ukazatel</FONT></A> </LI></UL>
  <LI><A 
  "Aritmetick%E9+instrukce"><FONT 
  size=2 face=Arial>Aritmetické instrukce</FONT></A><FONT size=2 face=Arial> 
  </FONT>
  <UL>
    <LI><A 
    "S%E8%EDt%E1n%ED"><FONT 
    size=2 face=Arial>Sèítání</FONT></A><FONT size=2 face=Arial> </FONT>
    <LI><A 
    "Od%E8%EDt%E1n%ED"><FONT 
    size=2 face=Arial>Odèítání</FONT></A><FONT size=2 face=Arial> </FONT>
    <LI><A 
    "N%E1soben%ED"><FONT 
    size=-1 face="Arial CE, Arial, Helvetica">Násobení</FONT></A><FONT size=2 
    face=Arial> </FONT>
    <LI><A 
    "D%EClen%ED"><FONT 
    size=-1 face="Arial CE, Arial, Helvetica">Dìlení</FONT></A><FONT size=2 
    face=Arial> </FONT>
    <LI><A 
    "Zm%ECna+po%E8tu+bit%F9"><FONT 
    size=2 face=Arial>Zmìna poètu bitù</FONT></A><FONT size=2 face=Arial> 
</FONT>
    <LI><A 
    "Pr%E1ce+s+%E8%EDsly+v+k%F3du+BCD"><FONT 
    size=2 face=Arial>Práce s èísly v kódu BCD</FONT></A><FONT size=-1 
    face="Arial CE, Arial, Helvetica"> </FONT></LI></UL>
  <LI><A 
  "Instrukce+logick%FDch+operac%ED"><FONT 
  size=2 face=Arial>Instrukce logickıch operací</FONT></A><FONT size=2 
  face=Arial> </FONT>
  <UL>
    <LI><A 
    "Pou%9Eit%ED+logick%FDch+operac%ED"><FONT 
    size=2 face=Arial>Pouití logickıch operací</FONT></A><FONT size=-1 
    face="Arial CE, Arial, Helvetica"> </FONT></LI></UL>
  <LI><A 
  "Instrukce+posuv%F9+a+rotac%ED"><FONT 
  size=2 face=Arial>Instrukce posuvù a rotací</FONT></A><FONT size=2 face=Arial> 
  </FONT>
  <UL>
    <LI><A 
    "Pou%9Eit%ED+posuv%F9+a+rotac%ED"><FONT 
    size=2 face=Arial>Pouití posuvù a rotací</FONT></A><FONT size=2 face=Arial> 
    </FONT></LI></UL>
  <LI><A 
  "Instrukce%20skoku"><FONT 
  size=-1 face="Arial CE, Arial, Helvetica">Instrukce skoku</FONT></A><FONT 
  size=-1 face="Arial CE, Arial, Helvetica"> </FONT>
  <UL>
    <LI><A 
    "N%E1v%EC%9At%ED"><FONT 
    size=2 face=Arial>Návìští</FONT></A><FONT size=2 face=Arial> </FONT>
    <LI><A 
    "Nepodm%EDn%ECn%FD+skok"><FONT 
    size=2 face=Arial>Nepodmínìnı skok</FONT></A><FONT size=2 face=Arial> 
</FONT>
    <LI><A 
    "Podm%EDn%ECn%FD+skok"><FONT 
    size=2 face=Arial>Podmínìnı skok</FONT></A><FONT size=2 face=Arial> 
    </FONT></LI></UL>
  <LI><A 
  "Nepodm%EDn%ECn%FD+a+podm%EDn%ECn%FD+cyklus"><FONT 
  size=2 face=Arial>Nepodmínìnı a podmínìnı cyklus</FONT></A><FONT size=-1 
  face="Arial CE, Arial, Helvetica"> </FONT>
  <LI><A 
  "Nastaven%ED+registru+p%F8%EDznak%F9"><FONT 
  size=2 face=Arial>Nastavení registru pøíznakù</FONT></A><FONT size=2 
  face=Arial> </FONT>
  <LI><A 
  "Vy%E8len%ECn%ED+pam%ECti+pro+prom%ECnn%E9+v+bloku+asm"><FONT 
  size=2 face=Arial>Vyèlenìní pamìti pro promìnné v bloku asm</FONT></A><FONT 
  size=-1 face="Arial CE, Arial, Helvetica"> </FONT>
  <LI><A 
  "Instrukce+pro+pr%E1ci+s+%F8et%ECzci"><FONT 
  size=2 face=Arial>Instrukce pro práci s øetìzci</FONT></A><FONT size=2 
  face=Arial> </FONT>
  <UL>
    <LI><A 
    "Prefix+opakov%E1n%ED"><FONT 
    size=2 face=Arial>Prefix opakování</FONT></A> </LI></UL>
  <LI><A 
  "Nedokumentovan%E9+instrukce"><FONT 
  size=2 face=Arial>Nedokumentované instrukce</FONT></A><FONT size=2 face=Arial> 
  </FONT>
  <LI><A 
  "Vol%E1n%ED+podprogram%F9"><FONT 
  size=2 face=Arial>Volání podprogramù</FONT></A><FONT size=2 face=Arial> 
</FONT>
  <LI><A 
  "Tvorba+podprogram%F9"><FONT 
  size=2 face=Arial>Tvorba podprogramù</FONT></A><FONT size=2 face=Arial> 
</FONT>
  <LI><A 
  "P%F8eru%9Aen%ED"><FONT 
  size=-1 face="Arial CE, Arial, Helvetica">Pøerušení</FONT></A><FONT size=2 
  face=Arial> </FONT>
  <LI><A 
  "Rezidentn%ED+programy"><FONT 
  size=2 face=Arial>Rezidentní programy</FONT></A><FONT size=2 face=Arial> 
  </FONT>
  <LI><A 
  "Literatura:"><FONT 
  size=-1 face="Arial CE, Arial, Helvetica">Literatura</FONT></A><FONT size=2 
  face=Arial> </FONT><BR><BR>
  </UL>
<H3><A name=Úvodem><FONT face="Arial CE, Arial, Helvetica"></FONT></A><FONT 
size=3 face=Arial>Úvodem </FONT></H3>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">ijeme v dobì, kdy nás 
poèítaèe obklopují na kadém kroku. Jejich vıhodou je monost ovlivnit své 
chování podle našich potøeb. Proto i ten nejlepší poèítaè nedokáe pracovat bez 
programu, kterı mu dává instrukce, jak se za kterıch okolností chovat. Proto 
bude vdy nutné, aby urèitá skupina lidí byla schopna tyto programy tvoøit. 
Myslím si, e programátoøi budou i pøi sebedokonalejším technickém vybavení 
spolutvùrci systémù, které ulehèují lidem práci. Mezi základní znalosti kadého 
programátora patøí alespoò minimální znalost Jazyka symbolickıch adres, kterému 
øíkáme assembler. Protoe tvorba sloitìjších programù jen v ASM86 by byla 
zdlouhavá, nabízí se monost vytváøet je ve vyšším programovacím jazyce, a v 
assembleru tvoøit jen ty jeho èásti, které se èasto opakují, a pøitom není 
jejich tvorba nároèná. Tyto bloky se nejlépe programují v tzv. vloeném 
assembleru. </FONT></P>
<H3><A name=Terminologie><FONT 
face="Arial CE, Arial, Helvetica"></FONT></A><FONT size=3 
face=Arial>Terminologie</FONT></H3>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>Bit</STRONG> - 
  nejniší jednotka nesoucí informaci, mùe nabıvat hodnoty buï 1, nebo 0. 
  </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>Slabika</STRONG> - 
  byte, pùlslovo, to je oznaèení pro 8 bitù (bity èíslujeme 7-0 popoøadì), mùe 
  nést hodnotu èísla se znaménkem (-128-127, shortint) nebo bez znaménka (0-255, 
  byte); za poèet slabik píšeme B (kB, MB). </FONT>
  <LI><FONT size=-1 
  face="Arial CE, Arial, Helvetica"><STRONG>Pùlslabika</STRONG> - pùlbyte, nibl, 
  oznaèení pro 4 bity. </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>Slovo</STRONG> - 
  word, dvì slabiky, oznaèení pro 16 bitù (bity èíslujeme 15-0 (7-0, 7-0) 
  popoøadì), mùe nést hodnotu èísla se znaménkem (-32768-32767, integer) nebo 
  bez znaménka (napø. adresa, 0-65535, word). </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>Instrukce</STRONG> 
  - pokyn mikroprocesoru k vykonání nìjaké èinnosti (pøesuò, seèti). </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>Program</STRONG> - 
  posloupnost instrukcí, které vedou k vykonání úlohy. Program je vìtšinou 
  uloen na disku ve formì souboru (typu EXE, COM). V nìm je uloena øada èísel, 
  které znamenají jednotlivé instrukce (strojovı kód). Po spuštìní je buï celı 
  program, nebo jeho èást, uloena do pamìti poèítaèe. </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>Pøekladaè</STRONG> 
  - program umoòující pøevést algoritmus zapsanı v textovém tvaru do strojového 
  kódu mikroprocesoru. Ve strojovém kódu jsou jednotlivé instrukce zapsány s 
  pomocí jedné, èi více slabik, které jsou pro kadou instrukci odlišné. 
  Jestlie tedy necháme poèítaè, aby èetl instrukce z èásti pamìti, kde jsou 
  data (ne operaèní kód instrukcí), dojde vìtšinou k "zmrznutí" poèítaèe, 
  protoe data mohou obsahovat kódy znamenající instrukce nesmyslného programu. 
  </FONT>
  <LI><FONT size=-1 
  face="Arial CE, Arial, Helvetica"><STRONG>Mikroprocesor</STRONG> - v kadém 
  poèítaèi nalezneme jeden, èi více mikroprocesorù. Jedná se o èást zajišující 
  pøesuny dat v poèítaèi a jejich zpracování. Uvnitø mikroprocesoru jsou vdy 
  tyto èásti: </FONT>
  <UL>
    <LI><FONT size=-1 
    face="Arial CE, Arial, Helvetica"><STRONG>Aritmeticko-logická jednotka 
    (ALU)</STRONG> - je to sèítaèka doplnìná o posuvné registry a logické 
    obvody. Vykonává operace spojené se zpracováním dat: matematické, logické a 
    posuvy (rotace). Poèet bitù, se kterımi je schopna ALU pracovat, udává, 
    kolikabitovı je celı mikroprocesor.</FONT> 
    <LI><FONT size=-1 
    face="Arial CE, Arial, Helvetica"><STRONG>Registry</STRONG> - jsou rychlé 
    pamìti urèené pro zaznamenávání dat a adres. Jednotlivé mikroprocesory se od 
    sebe liší poètem registrù a jejich velikostí, která udává, jak velké èíslo 
    jsme schopni v nìm uchovat. Jestlie registr slouí jako vstupní a vıstupní 
    pro hodnoty urèené ALU, øíkáme mu støadaè.</FONT> 
    <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>Dekodér 
    instrukcí </STRONG>- dekóduje èíslo, které pro mikroprocesor znamená 
    instrukci .</FONT> 
    <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>Obvody 
    øízení</STRONG> - zajistí vykonání instrukce vytvoøením posloupnosti 
    impulsù, která ovlivní jednotlivé èásti procesoru tak, aby po ukonèení této 
    posloupnosti byla instrukce vykonána. Tato posloupnost je ovlivnìna 
    mikroprogramem popisujícím jednotlivé instrukce. </FONT></LI></UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>Pamì</STRONG> - 
  je èást poèítaèe, kde je uloen program a data. </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>Zásobník</STRONG> 
  - je èást pamìti slouící k odkládání dat, pøípadnì k pøedávání hodnot mezi 
  podprogramy.</FONT> 
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>Vstupní-vıstupní 
  porty</STRONG> - za nì povaujeme obvody, které jsou urèené k pøedání dat do, 
  nebo z poèítaèe. </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>Adresa</STRONG> - 
  èíslo oznaèující místo slabiky v pamìti, nebo vstupního/vıstupního portu, se 
  kterım chceme pracovat (tzn. kam chceme zapsat, odkud chceme èíst). Maximální 
  velikost adresy urèuje velikost adresového prostoru, tedy poèet slabik v 
  pamìti, nebo poèet vstupnì/vıstupních portù. </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>Systémová sbìrnice 
  </STRONG>- je soustava vodièù urèená k transportu dat, øídících signálù a 
  adres mezi mikroprocesorem, pamìtí a vstupnì vıstupními obvody. Má tyto èásti: 
  </FONT>
  <UL>
    <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>Datová 
    sbìrnice</STRONG> - urèená k pøesunùm dat a kódù instrukcí.</FONT> 
    <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>Adresová 
    sbìrnice </STRONG>- urèená k pøesunùm adres slabik v pamìti a adres 
    vstupnì-vıstupních portù.</FONT> 
    <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>Øídící 
    sbìrnice</STRONG> - urèená k synchronizaci všech èástí poèítaèe.</FONT> 
  </LI></UL></LI></UL>
<H3><A name="Programátorskı model mikroprocesoru 8086"><FONT size=3 
face=Arial></FONT></A><FONT face="Arial CE, Arial, Helvetica">Programátorskı 
model mikroprocesoru 8086 </FONT></H3>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Obvod 8086 je univerzální 
šestnáctibitovı mikroprocesor. Má šestnáctibitovou ALU, to znamená, e je 
schopen provádìt operace s šestnáctibitovımi èísly. S okolím komunikuje po 
šestnáctibitové datové a dvacetibitové adresové sbìrnici. </FONT></P>
<H4><A name="Segmentace pamìti"><FONT size=-1 
face="Arial CE, Arial, Helvetica"></FONT></A><FONT size=2 face=Arial>Segmentace 
pamìti</FONT></H4>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Vzhledem k tomu, e obvod 
8086 je schopen práce s pamìtí o velikosti 1MB a obsahuje jen šestnáctibitové 
registry, je nutná tzv. segmentace pamìti. Jedná se o logické dìlení pamìti do 
blokù po 64kB. Tomuto bloku øíkáme segment a jeho poèátek urèuje programátor, 
pøípadnì je mu pøidìlen podle volného místa v pamìti. Jedinı poadavek na 
umístìní poèátku segmentu je, aby jeho adresa byla násobkem šestnácti. Umístìní 
jednotlivıch slabik v segmentu urèuje offsetová èást adresy (offset). Ta urèuje, 
kolikátá je slabika od poèátku segmentu. Adresa se skládá ze dvou èástí: segment 
a offset. Obì tyto èásti jsou šestnáctibitové. Protoe ale pro adresování pamìti 
je nutné dvacet bitù, jsou za segmentovou adresu vyjádøenou binárnì pøidány 
ètyøi bity s hodnotou nula (proto kadı segment zaèíná na násobku šestnácti). K 
tomuto dvacetibitovému èíslu je potom pøièteno šestnáctibitové èíslo urèující 
offsetovou adresu. Takto vzniká dvacetibitové èíslo znamenající skuteèné 
umístìní slabiky v pamìti (fyzická adresa). </FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Vıpoèet skuteèné adresy 
dvojkovì:</FONT></P>
<P><CODE>segment:ssssssssssssssss0000<BR>+offset:0000oooooooooooooooo<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--------------------<BR>&nbsp;adresa:aaaaaaaaaaaaaaaaaaaa</CODE></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">(segment jsou jednotlivé bity 
segmentové èásti adresy doplnìné na konci o ètyøi nuly, offset jsou jednotlivé 
bity offsetové èásti adresy doplnìné na zaèátku o ètyøi nuly, adresa je souèet, 
tedy jednotlivé bity skuteèné adresy)</FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Vıpoèet skuteèné adresy 
hexadecimálnì:</FONT></P>
<P><CODE>segment:ssss0<BR>+offset:0oooo<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-----<BR>&nbsp;adresa:aaaaa</CODE></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">(segment jsou jednotlivé 
cifry segmentové èásti adresy doplnìné na konci o jednu nulu, offset jsou 
jednotlivé cifry offsetové èásti adresy doplnìné na zaèátku o jednu nulu, adresa 
je souèet, tedy jednotlivé cifry skuteèné adresy)</FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Napøíklad: Místo v pamìti s 
adresou segmentu $AB1E a offsetu $1111&nbsp;má skuteènou adresu:</FONT></P>
<P><CODE>segment:AB1E0<BR>+offset:01111<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-----<BR>&nbsp;adresa:AC2F1</CODE></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Tento zpùsob adresace 
umoòuje snadnı pøenos programu v pamìti a jeho schopnost pracovat v kadé její 
èásti. Program si pro svoji èinnost vyèlení segment pro data, zásobník a 
strojovı kód (instrukce). Na tyto bloky ukazují jednotlivé segmentové registry. 
</FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Dùsledky 
segmentace:</FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">pøièteme-li k segmentové 
  èásti adresy jednièku, zvıšíme skuteènou hodnotu adresy o šestnáct (co je to 
  samé, jako bychom zvıšili offsetovou èást adresy o šestnáct)</FONT> 
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">skuteènost, e se adresa 
  tvoøí souètem dvou èísel, vede k tomu, e stejné místo v pamìti mùeme urèit 
  nìkolika kombinacemi adres segmentu a offsetu dávajícími v souètu jeho 
  fyzickou adresu</FONT> </LI></UL>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Pochopení segmentrace pamìti 
je spíše ve znalosti dvojkové a šestnáctkové èíselné soustavy.</FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">POZOR!!! Nemìli bychom 
zamìòovat pojmy segment a selektor. Segment urèuje jen umístìní bloku pamìti. 
Selektor je pouit u vyšších typù procesorù a jedná se vlastnì o poøadové èíslo 
v tabulce, která nese informace o vyèlenìnıch místech pamìti a jejich 
vlastnostech.</FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Z hlediska programátora jsou 
nejdùleitìjší registry. Ty se dìlí na</FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">registry pro všeobecné 
  pouití:</FONT> 
  <UL>
    <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">datové registry - 
    šestnáctibitové (všechny vyhovují definici støadaèe), které je moné dìlit 
    na poloviny po osmi bitech, jejich pouití bude probráno v dalších 
    kapitolách:</FONT> 
    <UL>
      <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>AX 
      (AH,AL)</STRONG> - støadaè pro násobení a dìlení, vstupnì-vıstuní 
      operace</FONT> 
      <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>BX 
      (BH,BL)</STRONG> - nepøímá adresace pamìti (báze)</FONT> 
      <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>CX 
      (CH,CL)</STRONG> - poèitadlo pøi cyklech, posuvech a rotacích</FONT> 
      <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>DX 
      (DH,DL)</STRONG> - nepøímá adresace vstupù/vıstupù</FONT> </LI></UL>
    <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">ukazatele a 
    indexregistry - pro umístìní adresy (offsetu):</FONT> 
    <UL>
      <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>BP</STRONG> - 
      bázovı registr</FONT> 
      <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>SP</STRONG> - 
      ukazatel zásobníku</FONT> 
      <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>DI</STRONG> - 
      adresa cíle</FONT> 
      <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>SI</STRONG> - 
      adresa zdroje</FONT> 
      <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>IP</STRONG> - 
      ukazatel na aktuální místo programu</FONT> </LI></UL></LI></UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">registr pøíznakù 
  (<STRONG>F</STRONG>) - obsahuje šest bitù (indikátorù), které mikroprocesor 
  nastavuje podle vısledku právì provedené operace, a umoòuje tak vìtvit 
  program: </FONT>
  <UL type=square>
    <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>CF</STRONG> - 
    Carry Flag, nastaví se do log. jedna, jestlie pøi právì provedené operaci 
    došlo k pøenosu z nejvyššího bitu osmibitového, nebo šestnáctibitového 
    vısledku; tento indikátor je také vyuíván pøi posuvech a rotacích</FONT> 
    <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>PF</STRONG> - 
    Parity Flag, se nastaví do log. jedna, pokud dolních osm bitù vısledku 
    obsahuje sudı poèet jednièek (a naopak)</FONT> 
    <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>AF</STRONG> - 
    Auxiliary Carry Flag, nastaví se do log. jedna pøi pøenosu 1 ze spodní 
    poloviny niší slabiky do vyšší; vyuívá se v BCD aritmetice (pøenos do 
    vyššího øádu) </FONT>
    <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>ZF</STRONG> - 
    Zero Flag, je v log. jedna pøi vısledku rovnému nule</FONT> 
    <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>SF</STRONG> - 
    Sign Flag, je v log. jedna pøi záporném vısledku</FONT> 
    <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>OF</STRONG> - 
    Overlow Flag, nastaví se do log. jedna, jestlie došlo k aritmetickému 
    pøeteèení (vısledek se nevešel do cíle) </FONT></LI></UL>
  <P><FONT size=-1 face="Arial CE, Arial, Helvetica">Tyto registry se nastavují 
  automaticky, jestlie probìhla instrukce, která je nastavuje. Registr F je 
  doplnìn i tøemi øídicími registry, které ovlivòují bìh programu:</FONT></P>
  <UL type=square>
    <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>TF</STRONG> - 
    Trap Flag, jestlie je nastavenı v log. jedna, mikroprocesor je uveden do 
    krokovacího reimu; je tak umonìno odladìní programu </FONT>
    <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>IF</STRONG> - 
    Interrupt Enable Flag, pøi log. jedna umoòuje vykonání maskovatelného 
    pøerušení, tzn. programovou obsluhu událostí </FONT>
    <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>DF</STRONG> - 
    Direction Flag, je urèen k øízení smìru zpracování øetìzcovıch operací; pøi 
    log. jedna se data zpracovávají sestupnì (a naopak) </FONT></LI></UL>
  <P><FONT size=-1 face="Arial CE, Arial, Helvetica">Tyto tøi registry mùe 
  nastavit jen programátor vhodnımi instrukcemi. Mikroprocesor je sám 
  nenastavuje. Jestlie s registrem pøíznakù jako s celkem pracujeme, je 
  šestnáctibitovı a má tvar: X, X, X, X, OF, DF, IF, TF, SF, ZF, X, AF, X, PF, 
  X, CF (bity X nejsou obsazeny)</FONT></P>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">segmentové registry - 
  urèené pro uloení druhé èásti adresy, segmentu:</FONT> 
  <UL type=square>
    <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>DS</STRONG> - 
    segment dat (promìnnıch)</FONT> 
    <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>ES</STRONG> - 
    pomocnı segment dat </FONT>
    <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>SS</STRONG> - 
    segment zásobníku</FONT> 
    <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>CS</STRONG> - 
    segment programu </FONT></LI></UL></LI></UL>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Mikroprocesor musí bıt 
schopen pracovat i se vstupy-vıstupy. Umístìní jednotlivıch portù urèuje 
šestnáctibitová adresa umístìná nejèastìji v registru DX. Pro programátora je 
dùleitá i ta skuteènost, e si mikroprocesor vytváøí tzv. frontu instrukcí. 
Jedná se o šest slabik znamenajících nìkolik instrukcí, které budou následovat 
po právì provádìné instrukci. Tato fronta je prùbìnì doplòována pøi operacích 
nezatìujících sbìrnice z pamìti. Protoe se ale jedná o deset za sebou jdoucích 
slabik v pamìti, je pøi instrukcích skoku v pamìti vyprázdnìna. Z tohoto dùvodu 
je vhodné, aby program obsahoval co nejmenší poèet skokù. Proto je v poslední 
dobì kladen dùraz na programovací jazyky, které podporují tzv. strukturované 
programování bez nepodmínìnıch skokù. Mezi nì (èásteènì) patøí Turbo Pascal a C. 
Je jasné, e programovací jazyk Basic se v tomto smyslu k mikroprocesoru nechová 
moc šetrnì a zpomaluje tak bìh programu. Mikroprocesor 80286 je strukturou i 
vlastnostmi podobnı 8086. Je schopen pracovat ve dvou reimech. V základním 
reálném témìø pøesnì simuluje obvod 8086. Pøesto v tomto reimu pøináší nìkterá 
rozšíøení pro nìkteré instrukce. Pokud v následujícím vıkladu pouiji rozšíøení 
instrukcí pro 80286, uvedu to poznámkou [286]. Zdrojovı text programu 
sestaveného i s pomocí instrukcí 80286 ve vkládaném assembleru staèí na prvním 
øádku (pøed uses) oznaèit direktivou {$G+}. </FONT></P>
<H3><A name="Vkládanı assembler v jazyce Turbo Pascal"><FONT size=3 
face=Arial></FONT></A><FONT face="Arial CE, Arial, Helvetica">Vkládanı assembler 
v jazyce Turbo Pascal </FONT></H3>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Vzhledem k jednoduchosti a 
názornosti se programovací jazyk Turbo Pascal vyuèuje na školách. My se budeme 
zabıvat tzv. vkládanım assemblerem. Jeho znalost umoní zrychlit námi psané 
programy, a pøitom vyuívat vıhod Pascalu ve snadném zápisu algoritmu. Vkládanı 
assembler je blok v programu psaném v jazyce Pascal. Tento blok zaèíná klíèovım 
slovem Asm a konèí end. Øádky programu ve vkládaném assembleru se neèíslují a 
nemusí konèit støedníkem v pøípadì, e na jednom øádku není více jak jedna 
instrukce (pøi více jak jedné instrukci musíme instrukce støedníkem oddìlit). 
Komentáøe se píší do sloenıch závorek, nesmìjí však bıt uvnitø oznaèení 
instrukce. Ve vloeném assembleru mùeme mìnit obsahy registrù AX, BX, CX, DX, 
SI, DI, ES, F. Pøed návratem z bloku asm musíme obnovit hodnoty v registrech 
BP,SP, SS, DS. </FONT></P>
<H3><A name="Instrukce pøesunù dat"><FONT 
face="Arial CE, Arial, Helvetica"></FONT></A><FONT size=3 face=Arial>Instrukce 
pøesunù dat </FONT></H3>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Kadı program musí bıt 
schopen pøesunù dat a to mezi registry, registry a pamìtí, registry a 
vstupy/vıstupy. Pøi této operaci si musíme vdy uvìdomit, kolikabitové èíslo 
pøesouváme. Poèet bitù je vìtšinou specifikován jménem pouitého registru 
(osmibitové - AH, AL, BH, BL, . . ., šestnáctibitové - AX, BX, BP, DI, ES, DS . 
. .). V pøípadì, e pouíváme jen pamì, specifikuje poèet bitù pro operaci 
oznaèení: </FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>BYTE</STRONG> 
  <STRONG>PTR</STRONG> oznaèení pam. místa - specifikuje slabiku </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>WORD</STRONG> 
  <STRONG>PTR</STRONG> oznaèení pam. místa - specifikuje slovo </FONT></LI></UL>
<H4><A name="Pøesuny registr - registr, registr - pamì"><FONT size=2 
face=Arial></FONT></A><FONT size=-1 face="Arial CE, Arial, Helvetica">Pøesuny 
registr - registr, registr - pamì </FONT></H4>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Všechny pøesuny tohoto typu 
provedeme univerzální instrukcí: </FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>MOV</STRONG> cíl, 
  zdroj - do cíle pøesuò ze zdroje (registr - registr, registr - pamì, registr 
  - hodnota, pamì - hodnota, seg. registr - registr, seg.registr - pamì) 
  </FONT></LI></UL>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Pouití této instrukce 
demonstruje pøíklad: </FONT></P>
<P><CODE>uses&nbsp;crt; <BR>var&nbsp;&nbsp;slovo:word; &nbsp;{v pamìti rezervuj 
16 bitù a oznaè je slovo} <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slabika:byte;{v 
pamìti rezervuj 8 bitù a oznaè je slabika} <BR>begin <BR>&nbsp;asm 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> AL,10 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{do registru AL dosaï 8 bitù, hodnotu 10} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> slabika,AL 
&nbsp;{do pamìti na místo ozn. slabika dosaï obsah AL} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> BX,10 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{do registru BX (16 bitovı) dosaï 10} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> slovo, BX 
&nbsp;&nbsp;{do pamìti na místo ozn. slovo dosaï 16 bitù BX} <BR>&nbsp;end; 
<BR>&nbsp;writeln (slabika,' ',slovo); <BR>&nbsp;readkey; <BR>end. </CODE></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Tento program má po pøekladu 
na místech promìnnıch v bloku asm oznaèení pamìového místa, které pro nì bylo 
vyèlenìno. Místo pro promìnné je vdy v segmentu globálních promìnnıch. 
Segmentová adresa tohoto bloku je vdy umístìna v registru DS. To, e DS ukazuje 
na segment dat programu, mùe vést k chybì, která spoèívá v jeho zmìnì a 
následném ètení z globálních promìnnıch. Take pozor! Po zmìnì registru DS je 
práce s globálními promìnnımi nemoná, protoe jsme si k nim uøízli cestu. Do 
segmentovıch registrù nejde dosadit hodnota pøímo. Tu nejrychleji dosadíme tak, 
e ji vloíme do nìkterého univerzáního registru a z nìj teprve do segmentového 
registru (napøíklad <STRONG>MOV</STRONG> AX,adresa; <STRONG>MOV</STRONG> ES,AX). 
</FONT></P>
<H4><A name="Metody adresace"><FONT size=-1 
face="Arial CE, Arial, Helvetica"></FONT></A><FONT size=2 face=Arial>Metody 
adresace </FONT></H4>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Místo (offset) v pamìti 
oznaèuje vdy urèitá hodnota zapsaná v hranatıch závorkách. Instrukce 
<STRONG>MOV</STRONG>&nbsp;<STRONG>BYTE</STRONG>&nbsp;<STRONG>PTR</STRONG>&nbsp;ES:[$100F],&nbsp;10 
znamená: na adresu slabiky offset 100F ($ oznaèuje pouití hexadecimální 
soustavy) v segmentu urèeném adresou v ES, dosaï hodnotu 10. Jestlie segment 
nespecifikujeme oznaèením a dvojteèkou, vztahuje se adresa k segmentu v DS. V 
praxi by tato metoda omezovala programátora v rozletu. Proto ASM86 umoòuje i 
další metody adresace. Ale popoøadì . . . </FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>Pøímá adresa 
  </STRONG><BR><STRONG>MOV</STRONG> AH, ES:[$1A40] - do registru AH pøedej 8 
  bitù z adresy urèené ES a èíslem <BR>Tuto metodu pouijeme, jestlie pøedem 
  víme adresu hledaného místa v pamìti. Na pomoc v Turbo Pascalu jsou operátory: 
  </FONT>
  <UL>
    <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>OFFSET</STRONG> 
    promìnná - vrací offsetovou adresu promìnné </FONT>
    <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>SEG</STRONG> 
    promìnná - vrací segmentovou adresu promìnné (pro globální promìnné vrací 
    vdy obsah DS)</FONT> </LI></UL>
  <P><FONT size=-1 face="Arial CE, Arial, Helvetica">Jejich pouití umoní 
  zjistit adresu promìnnıch deklarovanıch v èásti var (const . . .). </FONT></P>
  <P><FONT size=-1 face="Arial CE, Arial, Helvetica">Pøíklad: </FONT></P>
  <P><CODE>var promenna: byte;<BR>begin <BR>&nbsp;asm 
  <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> 
  </CODE><CODE><STRONG>BYTE</STRONG></CODE><CODE> 
  </CODE><CODE><STRONG>PTR</STRONG></CODE><CODE> [offset promenna], 10 {na 
  adresu slabiky promìnné dosaï 10} <BR>&nbsp;end; <BR>end.</CODE></P>
  <P><FONT size=-1 face="Arial CE, Arial, Helvetica">Segmentová adresa se v 
  tomto pøíkladu nemusí urèit. Je v DS, a ten se nemusí uvádìt. Pøekladaè 
  Pascalu tuto metodu pouívá i pro naše globální promìnné. Pøi pøekladu je 
  toti kadé promìnné pøidìleno místo v pamìti s pevnou offsetovou adresou 
  (take zápis <STRONG>OFFSET</STRONG> promìnná nese právì tuto adresu). 
  Specifikace, jestli se jedná o slabiku, nebo slovo, je nutná, protoe jinak by 
  procesor nevìdìl, jestli má èíslem obsadit jednu, nebo dvì slabiky. 
</FONT></P>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>Nepøímá adresa 
  <BR>MOV</STRONG> AH, ES:[BX] - do registru AH pøedej obsah pam. místa 
  specifikovaného adresou v BX <BR>Pozor! Do registru AH je uloen obsah v 
  pamìti na adrese v BX, ne obsah registru BX. Offsetová èást adresy je uloena 
  v nìkterém z adresovıch registrù BX, BP, SP, SI, DI. Vzhledem k tomu, e obsah 
  tìchto registrù mùeme mìnit, pouijeme tuto metodu v pøípadì pohybu po 
  pamìti. <BR>Pøíklad: <BR></FONT><CODE>var promenna: byte; <BR>begin 
  <BR>&nbsp;asm <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> 
  BX, offset promenna {do BX dosaï adresu promìnné} 
  <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> 
  </CODE><CODE><STRONG>BYTE</STRONG></CODE><CODE> 
  </CODE><CODE><STRONG>PTR</STRONG></CODE><CODE> [BX], 10 &nbsp;&nbsp;{na její 
  adresu dosaï hodnotu 10} <BR>&nbsp;end; <BR>end. </CODE>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>Bázová adresa 
  <BR>MOV</STRONG> AH, [BX + adresa] - k registru BX pøièti konstantu adresa, 
  vısledná hodnota je adresou odkud se má naèíst do registru AH <BR>Bázová 
  adresa se tvoøí s pomocí obsahu jednoho z bázovıch registrù BP, BX. Vıraz v 
  závorce se vyhodnotí, pøitom oznaèení registrù zastupuje jejich obsahy. Tento 
  druh adresy pouíváme pøi zjišování hodnot parametrù urèenıch pro podprogramy 
  (pøípadnì k pøístupu k lokálním promìnnım). </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>Indexovaná adresa 
  <BR>MOV</STRONG> AH, ES:[adresa + SI] &lt;=&gt; (je shodné) 
  <STRONG>MOV</STRONG> AH, adresa[SI] - registr SI seèti s konstantou adresa, 
  vısledek je hodnota adresy offsetu do pamìti <BR>Tento zpùsob adresace je 
  obdobou pøedchozí tvorby adresy. Pouívá se však pøi práci s bloky v pamìti. 
  Zde jsou k dispozici indexové registry SI, DI. <BR>Pøíklad: 
  <BR></FONT><CODE>var pole: array [0..9] of byte; <BR>begin <BR>&nbsp;asm 
  <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> SI, 0 
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{nuluj 
  registr SI} <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> 
  </CODE><CODE><STRONG>BYTE</STRONG></CODE><CODE> 
  </CODE><CODE><STRONG>PTR</STRONG></CODE><CODE> offset pole[SI], 10{adr. pole 
  seèti s SI a dosaï 10} <BR>&nbsp;end; <BR>end. </CODE>
  <P><FONT size=-1 face="Arial CE, Arial, Helvetica">Program dosadí na první 
  místo pole hodnotu. Protoe registr SI mùeme zvyšovat, budeme tímto zpùsobem 
  realizovat pohyb v poli. </FONT></P>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>Kombinovaná adresa 
  báze + index<BR>MOV</STRONG> AH, [BX + SI] &lt;=&gt; <STRONG>MOV</STRONG> AH, 
  [BX][SI] - obsahy registrù BX a SI seèti, vısledek je hodnota offsetu odkud se 
  má èíst <BR>Kombinovaná adresa umoòuje pracovat s adresou, která se skládá ze 
  souètu dvou registrù (jednoho bázového BX, BP a jednoho indexového SI, DI). 
  <BR>Pøíklad: <BR></FONT><CODE>var pole: array [0..9] of byte; <BR>begin 
  <BR>&nbsp;asm <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> 
  BX, offset pole &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{do registru BX dosaï 
  adresu pole} <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> 
  SI, 0 
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{do 
  registru SI dosaï 0} 
  <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> 
  </CODE><CODE><STRONG>BYTE</STRONG></CODE><CODE> 
  </CODE><CODE><STRONG>PTR</STRONG></CODE><CODE> [BX][SI], 10 {na první prvek v 
  poli ulo 10} <BR>&nbsp;end; <BR>end. </CODE>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>Kombinovaná adresa 
  pøímá + báze + index<BR>MOV</STRONG> AH, [adresa + BX + SI] &lt;=&gt; 
  <STRONG>MOV</STRONG> AH, adresa[BX][SI] - seèti registry BX, SI a pøièti 
  hodnotu adresa, vısledek je hodnota offsetu <BR>Tuto adresaci pouijeme 
  napøíklad pøi práci s hlavièkovımi soubory. Bázovı registr nastavíme na 
  poèátek bloku pamìti vyèlenìného k uloení souboru. Indexovı registr 
  vynulujeme. Konstantní hodnota (adresa) mùe bıt rovna délce hlavièky. 
  Zvyšováním hodnoty v indexovém registru se pohybujeme v datech hlavièkového 
  souboru. Další moné pouití této adresace je pøi pohybu v dvourozmìrnıch 
  polích. Hodnoty v obou registrech jsou indexy pole. Konstantní adresa je 
  adresou poèátku pole. </FONT></LI></UL>
<H4><A name="Prefix pøeskoèení"><FONT size=-1 
face="Arial CE, Arial, Helvetica"></FONT></A><FONT size=2 face=Arial>Prefix 
pøeskoèení </FONT></H4>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">V assembleru mikroprocesoru 
8086 se objevuje i novı vıraz. Prefix znamená urèitou specifikaci pro 
následující instrukci. Zatím jsme si ukázali, jak zmìnit specifikaci 
segmentového registru adresy s pomocí jeho oznaèení a dvojteèky. Dalším zpùsobem 
je pouití prefixu zmìny segmentu: <STRONG>SEGDS</STRONG>, 
<STRONG>SEGES</STRONG>, <STRONG>SEGCS</STRONG>, <STRONG>SEGSS</STRONG>. Tato 
oznaèení jsou prefixy pøeskoèení (zmìny segmentu) pro jednotlivé segmentové 
registry. Napøíklad: <STRONG>MOV</STRONG> AX, ES:[BX] je stejné, jako bychom 
pouili <STRONG>SEGES</STRONG> <STRONG>MOV</STRONG> AX, [BX] (i kdy zápis je 
rùznı, kód programu bude po pøekladu stejnı). </FONT></P>
<H4><A name="Práce se zásobníkem"><FONT size=-1 
face="Arial CE, Arial, Helvetica"></FONT></A><FONT size=2 face=Arial>Práce se 
zásobníkem </FONT></H4>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Zásobník je èást v pamìti 
poèítaèe vyhrazená k odkládání dat. Je organizovaná tak, e data, která jsou 
uloena naposledy, vyjímáme jako první. Na vrchol zásobníku ukazují adresy 
uloené v registrech SS a SP (pøípadnì BP). Pøidáváním dat do zásobníku se 
offset v SP automaticky sniuje o dvì (a naopak). Musíme si tedy uvìdomit, e do 
zásobníku mùeme odkládat jen šestnáctibitová data. Pro práci se zásobníkem 
slouí instrukce: </FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>PUSH</STRONG> 
  zdroj - do zásobníku ulo obsah zdroje (registr, pamì, [286] hodnota) </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>POP</STRONG> cíl - 
  ze zásobníku dosaï do cíle (registr, pamì) </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>PUSHA</STRONG> - 
  [286] do zásobníku ulo postupnì registry AX, CX, DX, BX, SP, BP, SI, DI 
  </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>POPA</STRONG> - 
  [286] ze zásobníku dosaï zpìt registry uloené instrukcí PUSHA </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>PUSHF</STRONG> - 
  do zásobníku ulo obsah registru F v šestnáctibitovém tvaru </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>POPF</STRONG> - 
  hodnotou ze zásobníku obsaï registr F </FONT></LI></UL>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Pøíklad: </FONT></P>
<P><CODE>var promenna:word; <BR>begin <BR>&nbsp;promenna:=10; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{do pamìti na adresu promìnné dosaï 10} 
<BR>&nbsp;asm <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> AX, 
promenna&nbsp; {obsah promìnné dosaï do registru AX} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> BX,$BBBB 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{do regisru BX dosaï èíslo} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>PUSH</STRONG></CODE><CODE> AX 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ulo obsah AX} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>PUSH</STRONG></CODE><CODE> BX 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ulo obsah BX} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> AX,$AAAA 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{pøepiš obsah AX} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> BX,$CCCC 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{pøepiš obsah BX} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>POP</STRONG></CODE><CODE> BX 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{obnov obsah 
BX} <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>POP</STRONG></CODE><CODE> AX 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{obnov obsah 
AX} <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> promenna, AX 
&nbsp;{vra obsah AX do promìnné} <BR>&nbsp;end; <BR>end. </CODE></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Tento program naznaèuje 
postup ukládání a vybírání dat do a ze zásobníku. V zásobníku jsou uloeny i 
lokální promìnné procedur a funkcí. Jsou zde i parametry, kterımi je podprogram 
volanı. (Proto lokální promìnné NEMAJÍ segmentovou adresu v DS.) Obèas potøebuje 
programátor uloit registr pøíznakù F, aby ho pozdìji mohl obnovit do pùvodního 
stavu. K tomu poíváme instrukci <STRONG>PUSHF</STRONG> (pro uloení) a 
<STRONG>POPF</STRONG> (pro obnovení). Jestlie ve vkládaném assembleru chceme 
mìnit nìkterı ze "zakázanıch" registrù (DS, BP), mùeme si jeho obsah uloit do 
zásobníku. Podmínkou je ale to, e nezmìníme registry SS, SP. Tím bychom si 
podøízli vìtev pod sebou. Další moné pouití zásobníku je pøi práci s èástí 
pamìtí, ve které máme pole slov (šestnáctibitovıch dat). Nasmìrováním vrcholu 
zásobníku (SS:SP) na konec tohoto pole mùeme instrukcemi <STRONG>PUSH</STRONG> 
a <STRONG>POP</STRONG> s tímto polem pracovat. Pøitom se bude automaticky 
zvyšovat a sniovat adresa. Pozor ale, obsahy SS a SP je nutné zase uschovat, 
nejlépe do pamìti na místa promìnnıch. V tom pøípadì ale nemùeme mìnit registr 
DS (ES). </FONT></P>
<H4><A name="Pøesuny vstup-vıstup - registr"><FONT size=2 
face=Arial></FONT></A><FONT size=-1 face="Arial CE, Arial, Helvetica">Pøesuny 
vstup-vıstup - registr </FONT></H4>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Kadı se nìkdy pokusíme 
zapsat na port a èíst z nìj. Je dobré si uvìdomit, e mùeme zapisovat osm i 
šestnáct bitù. Kadı port, stejnì jako slabika v pamìti, má svojí adresu. Pøi 
zápisu šestnácti bitù zapisujeme tedy i na port s adresou o jednu vyšší. Práci s 
porty provedeme instrukcemi: </FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>OUT</STRONG> 
  adresa portu, zdroj - pro zápis na port (AL, AX-&gt; port) </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>IN</STRONG> cíl, 
  adresa portu - pro ètení z portu (port-&gt; AL, AX) </FONT></LI></UL>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Data se ètou, nebo zapisují z 
(do) registru AL (osmibitovı pøístup), AX (šestnáctibitovı pøístup). Adresu 
portu specifikuje buï pøímo adresa (<STRONG>IN</STRONG> AL, $0F) pøi adrese 
osmibitové (spodních 256 portù), nebo registr DX, ve kterém je šestnáctibitová 
adresa (<STRONG>MOV</STRONG> DX, $F10; <STRONG>OUT</STRONG> DX, AL). </FONT></P>
<H4><A name="Další pøesuny"><FONT size=-1 
face="Arial CE, Arial, Helvetica"></FONT></A><FONT size=2 face=Arial>Další 
pøesuny</FONT></H4>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Mezi pøesuny dat patøí i: 
</FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>XCHG</STRONG> cíl, 
  zdroj - vzájemná vımìna hodnot zdroje a cíle (pamì - registr, registr - 
  registr) </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>LAHF</STRONG> - do 
  registru AH dosaï niší slabiku registru pøíznakù F </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>SAHF</STRONG> - z 
  registru AH dosaï do niší slabiky registru pøíznakù F </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>XLAT</STRONG> - do 
  AL dosaï obsah slabiky v pamìti s adresou v DS:[BX + AL] (práce s tabulkou) a 
  nìkteré øetìzcové instrukce o kterıch bude øeè pozdìji. </FONT></LI></UL>
<H3><A name="Instrukce dosazení adresy"><FONT size=3 face=Arial></FONT></A><FONT 
face="Arial CE, Arial, Helvetica">Instrukce dosazení adresy</FONT></H3>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">I kdy jsme si ji popsali, 
jak dosadit hodnotu adresy do nìkterého z adresovıch registrù, nebyly monosti 
ještì vyèerpány. Nejjednodušší je pouití instrukce: </FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>LEA</STRONG> 
  adresovı registr, pamì - do adresového registru dosaï adresu offsetu pamìti 
  </FONT></LI></UL>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Pamì je v tomto pøípadì 
oznaèena jako v instrukci <STRONG>MOV</STRONG>. Instrukce <STRONG>LEA</STRONG> 
BX, <STRONG>BYTE</STRONG> <STRONG>PTR</STRONG> [$FF00] a <STRONG>MOV</STRONG> 
BX, $FF00 jsou ekvivalentní. Protoe druhá instrukce je jednodušší, nemìla by 
instrukce <STRONG>LEA</STRONG> vıznam. Proto ji èastìji pouijeme pøi hledání 
hodnoty kombinované adresy (<STRONG>LEA</STRONG> DI, 100[BX][SI] - seète 
registry s èíslem 100 a dosadí vısledek do DI). Pro nás má vıznam i ve vkládaném 
assembleru. Zápis <STRONG>LEA</STRONG> BX, promìnná je jednodušší nì 
<STRONG>MOV</STRONG> BX, offset promìnná (i kdy instrukce vykonají stejnou 
práci). </FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Pøíklad: </FONT></P>
<P><CODE>var pole: array [0..9] of byte; <BR>begin <BR>&nbsp;asm 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>LEA</STRONG></CODE><CODE> BX, pole 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{do registru BX dosaï adresu 
pole} <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> 
</CODE><CODE><STRONG>BYTE</STRONG></CODE><CODE> 
</CODE><CODE><STRONG>PTR</STRONG></CODE><CODE> [BX],10 {na první místo v poli 
napiš 10} <BR>&nbsp;end; <BR>end. </CODE></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Zatím jsme ovlivòovali jen 
registry s offsetem. Pøestoe bychom byli schopni dosadit i segment, bylo by 
nutné pouít nejménì tøi instrukce (nezapomeòte, e <STRONG>MOV</STRONG> neumí 
dosadit hodnotu do segmentového registru pøímo). Abychom pochopili úspornìjší 
instrukci, musíme si zopakovat pojem ukazatel. </FONT></P>
<H4><A name=Ukazatel><FONT size=-1 
face="Arial CE, Arial, Helvetica"></FONT></A><FONT size=2 face=Arial>Ukazatel 
</FONT></H4>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Je typ promìnné, kterı nese 
celou adresu urèitého místa v pamìti. S pomocí tìchto promìnnıch mùeme potom 
dosazovat hodnoty na místa, kam ukazují. Èastìji myslíme oznaèením ukazatel 
právì tyto promìnné. </FONT></P>
<P><CODE>Pøíklad: </CODE></P>
<P><CODE>var cislo:byte; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{vyèleò v pamìti slabiku, 
oznaè jí èíslo} <BR>&nbsp;&nbsp;&nbsp;&nbsp;ukazatel:^byte; &nbsp;{vyèleò v 
pamìti ètyøi slabiky, které ponesou} 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{adresu 
na promìnnou typu byte, oznaè je ukazatel}<BR>begin 
<BR>&nbsp;ukazatel:=@cislo;&nbsp;&nbsp; {ukazateli pøiøaï adresu promìnné èíslo} 
<BR>&nbsp;ukazatel^:=10;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {na místo kam smìøuje 
ukazatel zapiš 10} <BR>&nbsp;writeln ('Hodnota promìnné 
èíslo:',cislo,'=',ukazatel^); {vypiš} <BR>end. </CODE></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Kromì ukazatelù na danı typ 
existují i ukazatele obecnì (typ pointer). Tyto typy jsou pro nás dùleité. 
Ètyøi slabiky, které jsou pro promìnnou tohoto typu vyèlenìny, nesou toti 
segment i offset adresy, kam ukazatel smìøuje. V assembleru existují dvì 
instrukce, které jsou schopny adresy uloené v ukazateli dosadit do registrù 
segmentu i offsetu: </FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>LES</STRONG> 
  registr, ukazatel - do ES dosaï segment a registru offset adresy smìru 
  ukazatele </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>LDS</STRONG> 
  registr, ukazatel - do DS dosaï segment a registru offset adresy smìru 
  ukazatele </FONT></LI></UL>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Pøíklad: </FONT></P>
<P><CODE>var promenna: byte; &nbsp;&nbsp;{v pamìti vyèleò slabiku s oznaèením 
promìnná} <BR>&nbsp;&nbsp;&nbsp;&nbsp;ukazatel: poiter; {v pamìti vyèleò ètyøi 
slabiky pro ukazatel} <BR>begin <BR>&nbsp;ukazatel:=@promenna; {nasmìruj 
ukazatele na promìnnou} <BR>&nbsp;asm 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>LES</STRONG></CODE><CODE> BX, ukazatel 
&nbsp;&nbsp;&nbsp;{nastav ES:BX na adresu promìnné} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>SEGES</STRONG></CODE><CODE> 
</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> 
</CODE><CODE><STRONG>BYTE</STRONG></CODE><CODE> 
</CODE><CODE><STRONG>PTR</STRONG></CODE><CODE> [BX],10 {zapiš na tuto adresu} 
<BR>&nbsp;end; writeln (promenna); &nbsp;&nbsp;&nbsp;{vypiš obsah promìnné} 
<BR>end. </CODE></P>
<H3><A name="Aritmetické instrukce"><FONT 
face="Arial CE, Arial, Helvetica"></FONT></A><FONT size=3 face=Arial>Aritmetické 
instrukce </FONT></H3>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Programátor pøi své èinnosti 
potøebuje nejen pøesuny dat. V kadém programu jsou nutné i vıpoèty a to s 
bìnımi daty, nebo s adresami. Ty se v assembleru provádìjí jen s celımi èísly. 
Operace s desetinnımi èísly jsou zdlouhavé, i kdy jsou proveditelné pomocí 
urèitıch algoritmù. ASM86 pro nì ale nemá instrukce. Vìtšina matematickıch 
operací se provádí s èísly v registrech nebo v pamìti. Oznaèení operandù je 
shodné jako pøi pøesunech. Zároveò tyto instrukce nastavují indikátory registru 
F. Umoní tak vìtvit program. Informace o nastavovanıch indikátorech najdeme v 
tabulce instrukcí (<STRONG>+</STRONG>). </FONT></P>
<H4><A name=Sèítání><FONT size=-1 
face="Arial CE, Arial, Helvetica"></FONT></A><FONT size=2 face=Arial>Sèítání 
</FONT></H4>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Pøi tvorbì programu si musíme 
ujasnit, jestli chceme k cílovému místu pøièíst 1, nebo jiné èíslo. Podle toho 
volíme instrukci:</FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>INC</STRONG> cíl - 
  k cíli pøièti jedna (registr, pamì) </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>ADD</STRONG> cíl, 
  zdroj - k cíli pøièti zdroj (registr - hodnota, pamì -hodnota, registr - 
  registr, pamì - registr, registr - pamì) </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>ADC</STRONG> cíl, 
  zdroj - stejnì jako <STRONG>ADD</STRONG>, ale pøièti i bit CF (pøenos)</FONT> 
  </LI></UL>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Pøíklady: </FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>INC</STRONG> AX - 
pøièti k registru AX hodnotu 1 <BR><STRONG>INC</STRONG> <STRONG>WORD</STRONG> 
<STRONG>PTR</STRONG> [BX] - pøièti k slovu na adrese urèené DS:BX hodnotu 1 
<BR><STRONG>INC</STRONG> <STRONG>BYTE</STRONG> <STRONG>PTR</STRONG> CS:[adresa] 
- pøièti k slabice na adrese urèené CS:adresa (konstantní) 1 
<BR><STRONG>SEGES</STRONG> <STRONG>INC</STRONG> <STRONG>BYTE</STRONG> [DI + 2] - 
pøièti k slabice na adrese ES:DI + 2 hodnotu 1 <BR><STRONG>ADD</STRONG> AX, BX - 
ke slovu v registru AX pøièti obsah registru BX (slovo) <BR><STRONG>ADD</STRONG> 
AH, 8 - k slabice v registru AH pøièti èíslo 8} <BR><STRONG>SEGCS</STRONG> 
<STRONG>ADD</STRONG> DX, <STRONG>WORD</STRONG> <STRONG>PTR</STRONG> [BX] - k 
registru DX pøièti slovo na adrese CS:BX <BR><STRONG>ADD</STRONG> promenna, 5 - 
k deklarované promìnné pøièti 5 <BR><STRONG>ADD</STRONG> <STRONG>BYTE</STRONG> 
<STRONG>PTR</STRONG> [SI], 30 - k slabice na adrese DS:SI pøièti 30} 
<BR><STRONG>ADD</STRONG> <STRONG>BYTE</STRONG> <STRONG>PTR</STRONG> ES:[BP], AL 
- k slabice na adrese ES:BP pøièti obsah registru AL </FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Pokud pøi tìchto operacích 
dojde k pøeplnìní cíle, nastaví se registr OF do log. 1. Aby pøi odlaïování 
vašich programù nedošlo ke zbyteènım hádkám s pøekladaèem, uvìdomte si, e zdroj 
i cíl musí mít stejnı poèet bitù (tzn. 8, nebo 16). </FONT></P>
<H4><A name=Odèítání><FONT size=-1 
face="Arial CE, Arial, Helvetica"></FONT></A><FONT size=2 face=Arial>Odèítání 
</FONT></H4>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Instrukce slouící k odèítání 
jsou zápisem operandù shodné s instrukcemi pro sèítání. Proto si uvedeme jen 
jejich seznam: </FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>DEC</STRONG> cíl - 
  d cíle odeèti 1 (registr, pamì) </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>SUB</STRONG> cíl, 
  zdroj - od cíle odeèti zdroj (registr - hodnota, pamì - hodnota, registr - 
  registr, pamì - registr, registr - pamì) </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>SBB</STRONG> cíl, 
  zdroj - stejnì jako SUB, ale odeèti i bit CF Pøíklady by byly shodné se 
  sèítáním. </FONT></LI></UL>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Pøesto jsou zde specifické 
instrukce: </FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>NEG</STRONG> cíl - 
  otoè znaménko v cíli (registr, pamì) </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>CMP</STRONG> cíl, 
  zdroj - odeèti bez zmìny cíle, nastav jen registr F (registr - hodnota, pamì 
  - hodnota, registr - registr, pamì - registr, registr - pamì) 
</FONT></LI></UL>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Instrukce 
<STRONG>CMP</STRONG> porovnává dvì èísla odeètením. Protoe ale nedojde k jejich 
zmìnì, pouijeme tuto instrukci pøed vìtvením programu. Za <STRONG>CMP</STRONG> 
toti vìtšinou následu+jí instrukce skoku závislé na stavu pøíznakù registru F. 
</FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Pøíklad: </FONT></P>
<P><CODE>uses crt; <BR>var a,b,s,r:integer; <BR>begin <BR>&nbsp;clrscr; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{vyma obrazovku} <BR>&nbsp;write 
('a=');<BR>&nbsp;readln(a);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{vstup hodnoty a} 
<BR>&nbsp;write ('b=');<BR>&nbsp;readln(b);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{vstup 
hodnoty b} <BR>&nbsp;asm 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{zaèátek bloku 
asm} <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> AX, a 
&nbsp;&nbsp;&nbsp;&nbsp;{do AX vlo hodnotu promìnné a (z pamìti)} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>ADD</STRONG></CODE><CODE> AX,b 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{k AX pøièti hodnotu promìnné b} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> s, AX 
&nbsp;&nbsp;&nbsp;&nbsp;{do promìnné s vlo souèet z registru AX} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> AX,a 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{znovu naber a} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>SUB</STRONG></CODE><CODE> AX,b 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{odeèti od AX hodnotu b} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> r,AX 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{do promìnné r vlo rozdíl z registru AX} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>INC</STRONG></CODE><CODE> a 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{k a pøièti 1} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>DEC</STRONG></CODE><CODE> b 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{od b odeèti 1} <BR>&nbsp;end; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{konec bloku asm} 
<BR>&nbsp;writeln ('a+b=',s,' a-b=',r);{vypiš obsahy promìnnıch} 
<BR>&nbsp;writeln ('a+1=',a,' b-1=',b); <BR>end. </CODE></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Uvedenı pøíklad ukazuje 
nejjednodušší pouití instrukcí <STRONG>ADD</STRONG>, <STRONG>SUB</STRONG>, 
<STRONG>INC</STRONG>, <STRONG>DEC</STRONG>. Všimnìte si, e se zápisy adres 
promìnnıch si nemusí programátor ani moc lámat hlavu. V tom mu toti pomáhá 
pøekladaè Pascalu. </FONT></P>
<H4><A name=Násobení><FONT size=-1 
face="Arial CE, Arial, Helvetica"></FONT></A><FONT size=2 face=Arial>Násobení 
</FONT></H4>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">I kdy programátoøi neradi 
pouívají instrukce násobení a dìlení pro jejich dlouhou dobu provádìní (na 
procesoru 8086, u jinıch procesorù je u rychlé), ASM86 je má. Nìkdy dokonce 
neexistuje jiná monost ne je pouít. I tyto operace jsou definovány jen na 
celıch èíslech. Rozlišujeme také, jestli je provádíme se znaménkem, nebo bez 
znaménka.</FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>MUL</STRONG> zdroj 
  - registr AL vynásob se zdrojem (osmibitovı registr, nebo pamì) a vısledek 
  zapiš do registru AX (osmibitové násobení).</FONT> 
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>MUL</STRONG> zdroj 
  - registr AX vynásob se zdrojem (šestnáctibitovı registr, nebo pamì) a 
  vısledek (32 bitù) zapiš do registrového páru DX,AX za sebou (šestnáctibitové 
  násobení). </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>IMUL</STRONG> 
  zdroj - jako <STRONG>MUL</STRONG> ale násobení se znaménkem 
  <STRONG>IMUL</STRONG> cíl,[zdroj,]konstanta - [286], do cíle vlo souèin 
  zdroje a konstanty (šestnáctibitovı registr - šestnáctibitovı registr - 
  hodnota, šestnáctibitovı registr - slovo v pamìti - hodnota, šestnáctibitovı 
  registr - osmibitová hodnota, to znamená cíl := zdroj * konstanta, nebo cíl := 
  cíl * konstanta) </FONT></LI></UL>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">POZOR!, o kolikabitové 
násobení se jedná urèuje oznaèení místa zdroje. </FONT></P>
<H4><A name=Dìlení><FONT size=-1 
face="Arial CE, Arial, Helvetica"></FONT></A><FONT size=2 face=Arial>Dìlení 
</FONT></H4>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Tato operace je jednou z 
nejzdlouhavìjších. Její provádìní trvá (na 8086) a 190 period hodin (sèítání 
trvá kolem 3 period). Jeho vıhodou je ale to, e je moné zjistit jak vısledek 
po celoèíselném dìlení (DIV), tak i zbytek po celoèíselném dìlení (MOD). A to 
všechno jen jednou instrukcí.</FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>DIV</STRONG> zdroj 
  - registr AX vydìl zdrojem (osmibitovı registr, nebo pamì) a podíl ulo do 
  AL, zbytek po dìlení ulo do AH (Osmibitové dìlení)</FONT> 
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>DIV</STRONG> zdroj 
  - dvojslovo v registrech DX, AX vydìl zdrojem (šestnáctibitovı registr, nebo 
  pamì) a podíl ulo do AX, zbytek po dìlení ulo do DX (Šestnáctibitové 
  dìlení)</FONT> 
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>IDIV</STRONG> 
  zdroj - jako <STRONG>DIV</STRONG> ale dìlení se znaménkem Pouití tìchto 
  instrukcí je podobné jako násobení. Program si musíme ošetøit tak, aby nemohlo 
  dojít k dìlení nulou. Jestlie k nìmu pøesto dojde, procesor zavolá pøerušení 
  <STRONG>INT</STRONG> 0. </FONT></LI></UL>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Pøíklad: </FONT></P>
<P><CODE>uses crt; <BR>var a,b,d,z:byte; <BR>&nbsp;&nbsp;&nbsp;&nbsp;s:word; 
<BR>begin <BR>&nbsp;clrscr; <BR>&nbsp;write ('a=');<BR>&nbsp;readln (a); 
<BR>&nbsp;write ('b=');<BR>&nbsp;readln (b); <BR>&nbsp;asm 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> AL,a {do AL vlo 
hodnotu a} <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MUL</STRONG></CODE><CODE> b 
&nbsp;&nbsp;&nbsp;{vynásob hodnotou b (v pamìti)} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> s,AX {do promìnné 
s vlo souèin z registru AX} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> AH,0 {nuluj AH 
(èíslo je jen 8 bitové)} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> AL,a {do AL vlo 
hodnotu a} <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>DIV</STRONG></CODE><CODE> b 
&nbsp;&nbsp;&nbsp;{vydìl promìnnou b} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> d,AL {vısledek 
vlo do promìnné d} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> z,AH {zbytek po 
dìlení vlo do promìnné z} <BR>&nbsp;end; <BR>&nbsp;writeln ('a*b=',s); 
<BR>&nbsp;writeln ('a div b=',d,' a mod b=',z); <BR>&nbsp;readkey; <BR>end. 
</CODE></P>
<H3><A name="Zmìna poètu bitù"><FONT 
face="Arial CE, Arial, Helvetica"></FONT></A><FONT size=3 face=Arial>Zmìna poètu 
bitù </FONT></H3>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Èasto potøebujeme opravit 
šestnáctibitové èíslo na osmibitové a naopak. Pøi této zmìnì mùe ale dojít ke 
ztrátì informace v pøípadì úbytku bitù. Pøevod èísel bez znaménka provedeme 
nejjednodušeji vyuitím pùlení registrù. </FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>Slabika -&gt; 
  Slovo <BR></STRONG>Do šestnáctibitového registru naèteme do dolní poloviny 
  slabiku. Horní polovinu nulujeme. Slovo potom naèteme ze všech šestnácti bitù: 
  <BR></FONT><CODE>var b:byte; <BR>&nbsp;&nbsp;&nbsp;&nbsp;w:word; <BR>begin 
  <BR>&nbsp;b:=10; <BR>&nbsp;asm 
  <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> AL, 
  b&nbsp;&nbsp;&nbsp; &nbsp;{do AL osm bitù z promìnné b} 
  <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> AH, 0 
  &nbsp;&nbsp;&nbsp;&nbsp;{nuluj AH} 
  <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> w, AX 
  &nbsp;&nbsp;&nbsp;&nbsp;{do promìnné w vlo všech šestnáct bitù} 
  <BR>&nbsp;end; <BR>end. </CODE>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>Slovo-&gt; Slabika 
  <BR></STRONG>Operace je opaèná. Šestnáctibitové èíslo vloíme do celého 
  šestnáctibitového registru. Do slabiky potom vloíme jen spodních osm bitù. 
  Ale pozor, tady mùe dojít ke ztrátì bitù v horních osmi bitech. Protoe 
  úprava èísel se znaménky by byla sloitá, pøichází opìt na pomoc ASM86 s 
  instrukcemi: </FONT>
  <UL>
    <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>CBW</STRONG> - 
    pøeveï obsah AL do AX se zachováním znaménka </FONT>
    <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>CWD</STRONG> - 
    pøeveï obsah AX do DX, AX (32 bitù) se zachováním znaménka 
  </FONT></LI></UL></LI></UL>
<H3><A name="Práce s èísly v kódu BCD"><FONT size=3 face=Arial></FONT></A><FONT 
face="Arial CE, Arial, Helvetica">Práce s èísly v kódu BCD</FONT></H3>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Èísla v BCD kódu mohou bıt 
uloena v tìchto formátech: </FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>Nezhuštìnı tvar 
  <BR></STRONG>V jedné slabice je uloena jedna èíslice v BCD kódu. Má hodnotu 
  0-9 a obsazuje tedy jen spodní 4 bity. Horní polovina slabiky je nulová (to se 
  doporuèuje pro operace násobení a dìlení, pro sèítání a odèítání mùe mít 
  libovolnı obsah). Tento tvar je vhodnı pro pøevod do kódu ASCII. Staèí jen k 
  slabice pøièíst èíslo 48 (logickı souèet s èíslem $30). </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>Zhuštìnı tvar 
  <BR></STRONG>V jedné slabice jsou uloeny dvì BCD èíslice. Spodní 4 bity nesou 
  hodnotu nišího øádu (jednotky), horní 4 nesou hodnotu vyššího øádu (desítky). 
  Do slabiky jde tedy uloit èíslo v rozsahu 0-99. ASM86 nepodporuje pøímo 
  matematické operace s takto kódovanımi èísly. Pøesto obsahuje instrukce pro 
  jejich úpravu po provedení bìnıch operací urèenıch pro èísla v pøirozeném 
  dvojkovém kódu (obyèejné dvojkovì uloené èíslo). V ASM86 nejdeme i instrukce, 
  které pro tyto operace èísla v BCD kódu pøipraví. Jedná se o instrukce: 
  <STRONG>AAA</STRONG>, <STRONG>AAD</STRONG>, <STRONG>AAM</STRONG>, 
  <STRONG>AAS</STRONG>, <STRONG>DAA</STRONG>, <STRONG>DAS</STRONG> (bliší 
  informace v </FONT><A 
  href="http://www.mujweb.cz/www/j_schwarz/inssou86.html#Instrukce%20aritmetick%FDch%20operac%ED"><FONT 
  size=2 face=Arial>tabulce instrukcí</FONT></A><FONT size=2 face=Arial>). 
  </FONT></LI></UL>
<H3><A name="Instrukce logickıch operací"><FONT size=3 
face=Arial></FONT></A><FONT face="Arial CE, Arial, Helvetica">Instrukce 
logickıch operací </FONT></H3>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Logické instrukce jsou jednou 
z dobrıch pomùcek programátorù. ASM86 je schopen provádìt všechny bìné logické 
operace, a to se slovem nebo slabikou. Chybí zde tedy instrukce pro jednotlivé 
bity. Ty však volbou vhodnıch algoritmù mùeme lehce nahradit. </FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>NOT</STRONG> zdroj 
  - neguj všechny bity zdroje </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>AND</STRONG> 
  zdroj, cíl - logickı souèin zdroje s cílem ulo do zdroje (registr - hodnota, 
  pamì - hodnota, registr - registr, pamì - registr, registr - pamì) </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>TEST</STRONG> 
  zdroj, cíl - logickı souèin zdroje s cílem, ale nastav jen registr pøíznakù F 
  (registr - hodnota, pamì - hodnota, registr - registr, pamì - registr, 
  registr - pamì) </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>OR</STRONG> zdroj, 
  cíl - logickı souèet zdroje s cílem ulo do zdroje (registr - hodnota, pamì - 
  hodnota, registr - registr, pamì - registr, registr - pamì) </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>XOR</STRONG> 
  zdroj, cíl - logickı vyluèovací souèet zdroje s cílem ulo do zdroje (registr 
  - hodnota, pamì - hodnota, registr - registr, pamì - registr, registr - 
  pamì) </FONT></LI></UL>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Kolikabitová operace je, 
urèuje opìt specifikace zdroje a cíle. Instrukci <STRONG>TEST</STRONG> pouijeme 
k nastavení pøíznakového registru, a tak mùeme vìtvit program, ani bychom 
ovlivnili hodnoty zdroje a cíle. </FONT></P>
<H4><A name="Pouití logickıch operací"><FONT size=2 face=Arial></FONT></A><FONT 
size=-1 face="Arial CE, Arial, Helvetica">Pouití logickıch operací </FONT></H4>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Vymaskování slabiky nebo 
slova <BR>Èasto potøebuje programátor nastavit nìkteré bity slabiky, nebo slova 
do hodnoty log. 1, nebo 0. K tomu mu velmi dobøe poslouí právì logické operace 
AND nebo OR. Máme-li slabiku ve tvaru XXXXAXXX v registru AL a chceme, aby bity 
X mìly hodnotu 0 a hodnota bitu A zùstala zachována, provedeme instrukci 
<STRONG>AND</STRONG>&nbsp;AL,&nbsp;$08&nbsp;(=00001000). Máme-li slabiku ve 
tvaru XXXXAXXX v registru AL a chceme, aby bity X mìly hodnotu 1 a hodnota bitu 
A zùstala zachována, provedeme instrukci 
<STRONG>OR</STRONG>&nbsp;AL,&nbsp;$F7&nbsp;(=11110111). </FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>Nulování registru 
<BR></STRONG>Zajímavìjší ne instrukce <STRONG>MOV</STRONG> registr,0 je nulovat 
pomocí <STRONG>XOR</STRONG> registr, registr. Efekt je stejnı, doba vykonání 
operace je kratší. </FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>Zjištìní zbytku po 
celoèíselném dìlení mocninami 2 <BR></STRONG>Kdybychom vdy, kdy chceme zjistit 
zbytek po dìlení mocninami 2 (a ten èasto potøebujeme) pouívali instrukci 
<STRONG>DIV</STRONG>, program bychom zdrovali. Staèí si jen uvìdomit, e mùeme 
zjistit hodnotu bitù v øádech za log. 1 v binárním tvaru dìlence. Chceme-li 
zjistit zbytek po celoèíselném dìlení 2 (sudé, liché èíslo) èísla v registru AL, 
staèí jen pouít instrukci <STRONG>AND</STRONG> AL,1. V registru AL je potom jen 
buï 1 (liché èíslo), nebo 0 (sudé èíslo). Pro lepší orientaci poslouí pøehled: 
</FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>AND</STRONG> AL, 1 
  &nbsp;(&nbsp;1 = 00000001) -&gt; AL := AL mod 2 (&nbsp;2 = 00000010)</FONT> 
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>AND</STRONG> AL, 3 
  &nbsp;(&nbsp;3&nbsp;= 00000011) -&gt; AL := AL mod 4 (&nbsp;4 = 
  00000100)</FONT> 
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>AND</STRONG> AL, 7 
  &nbsp;(&nbsp;7&nbsp;= 00000111) -&gt; AL := AL mod 8 (&nbsp;8 = 00001000) 
  </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>AND</STRONG> AL, 
  15 (15 = 00001111) -&gt; AL := AL mod 16(16 = 00010000) </FONT></LI></UL>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Pøevod èísla v nezhuštìném 
BCD na ASCII <BR>Velmi jednoduchım prostøedkem, jak pøevést èíslo v rozsahu 0-9 
do hodnoty jeho znaku v tabulce ASCII, je logickı souèet s èíslem $30 (to je 
stejné jako pøiètení 48). Pouitím této úpravy èísel v kódu BCD je zobrazení i 
velkıch èísel jednoduché. </FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Pøíklad: </FONT></P>
<P><CODE>var slabika:byte; <BR>&nbsp;&nbsp;&nbsp;&nbsp;znak:char; <BR>begin 
<BR>&nbsp;repeat <BR>&nbsp;&nbsp;readln (slabika); <BR>&nbsp;until slabika in 
[0..9]; <BR>&nbsp;asm 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> AL, slabika {do 
registru AL pøedej hodnotu slabiky} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>OR</STRONG></CODE><CODE> AL, 
$30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {pøeveï na ASCII} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> znak, AL 
&nbsp;&nbsp;&nbsp;{do promìnné znak pøedej ASCII hodnotu èísla} <BR>&nbsp;end; 
<BR>&nbsp;writeln (znak); <BR>end. </CODE></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">V pøíkladu je naètené èíslo z 
intervalu 0..9 pøevedeno do ASCII s pomocí log. instrukce <STRONG>OR</STRONG>. 
</FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Pøed dalším pøíkladem si 
musíme vysvìtlit, jak ukládá Pascal øetìzce (typu string). Za øetìzec je zde 
povaováno pole slabik, které má na prvním místì délku øetìzce a na dalších 
místech jsou kódy ASCII zapsanıch znakù. Informace o délce øetìzce je dùleitá 
pro jeho správné zobrazení. Ten proto nemusí obsahovat speciální ukonèovací 
znak. </FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Pøíklad: </FONT></P>
<P><CODE>var slovo:string; <BR>&nbsp;&nbsp;&nbsp;&nbsp;i:byte; <BR>begin 
<BR>&nbsp;for i:=0 to 9 do <BR>&nbsp;asm 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> DI, 
</CODE><CODE><STRONG>OFFSET</STRONG></CODE><CODE> slovo {do registru DI ulo 
adresu promìnné slovo} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>INC</STRONG></CODE><CODE> DI 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{posuò 
se a za slabiku délky øetìzce} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>XOR</STRONG></CODE><CODE> AH,AH 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{nuluj AH} 
</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> AL,i {do AL vlo krok i} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>ADD</STRONG></CODE><CODE> DI,AX 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{pøièti krok k 
adrese (posuv po øetìzci)} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>OR</STRONG></CODE><CODE> AL,$30 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{pøeveï obsah 
AL na ASCII znak} <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> 
[DI],AL &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{pøesuò znak do 
øetìzce} <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>INC</STRONG></CODE><CODE> 
</CODE><CODE><STRONG>BYTE</STRONG></CODE><CODE> 
</CODE><CODE><STRONG>PTR</STRONG></CODE><CODE> [OFFSET slovo]{zvyš délku 
øetìzce} <BR>&nbsp;end; <BR>&nbsp;writeln (slovo); <BR>&nbsp;readln; <BR>end. 
</CODE></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Tento pøíklad vytvoøí slovo 
typu string s èísly od 0 do 9. To, e zatím nevíme, jak se v ASM86 tvoøí cykly, 
není na závadu. Prostì si pomùeme znalostmi z Pascalu. </FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>Kódování 
<BR></STRONG>Kadı rád chrání svá data pøed neoprávnìnım pøístupem kódováním. K 
tomu dobøe slouí logická operace XOR. Postup kódování naznaèuje postup. 
Provedeme-li operaci XOR s konstantou a kódovanım èíslem, získáme kódované 
èíslo. Pokud s kódovanım èíslem provedeme opìt XOR se stejnou konstantou, 
získáme zpìt pùvodní èíslo. Èísla kódovaná pøidáme do EXE souboru programu. Pøed 
jejich pouitím je dekódujeme. Protoe tato èísla mohou nést napø. jméno autora 
(v ASCII), je jméno pro bìného uivatele po zakódování neèitelné (a tedy lehce 
nepøepsatelné v souboru EXE). Pozor! Hodnota konstanty musí bıt pøi kódování i 
dekódování stejná. Tento postup mùeme libovolnì pozmìòovat podle úrovnì našich 
znalostí (napø. xorovat první znak s druhım, druhı s tøetím, . . .). </FONT></P>
<H3><A name="Instrukce posuvù a rotací"><FONT size=3 face=Arial></FONT></A><FONT 
face="Arial CE, Arial, Helvetica">Instrukce posuvù a rotací </FONT></H3>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Tyto instrukce jsou dobrım 
pomocníkem kadému, kdo je umí pouívat. Jedná se o bitovı posuv uvnitø slabiky, 
nebo slova. Poèet bitù posuvu je specifikován pouitım registrem, nebo oznaèením 
pamìového místa. </FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Posuvy: </FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>SHL</STRONG> cíl, 
  poèet &lt;=&gt; SAL cíl, poèet - v cíli posuò tak, e nejniší bit nahradíš 
  nulou, ostatní pøesuò z nišího místa o jedno vıše, nejvyšší bit pøesuò do 
  registru CF (registr - CL (kterı nese poèet krokù posuvu), registr - 1, [286] 
  registr - poèet krokù posuvu) </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>SHR</STRONG> cíl, 
  poèet - v cíli posuò tak, e nejvyšší bit nahradíš nulou, ostatní pøesuò z 
  vyššího místa na niší, nejniší bit pøesuò do registru CF (registr - CL 
  (kterı nese poèet krokù posuvu), registr - 1, [286] registr - poèet krokù 
  posuvu) </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>SAR</STRONG> cíl, 
  poèet - v cíli posuò tak, e nejvyšší bit nezmìníš a kopíruj ho do nišího 
  bitu, ostatní pøesuò z vyššího místa na niší, nejniší bit pøesuò do registru 
  CF (registr - CL (kterı nese poèet krokù posuvu), registr - 1, [286] registr - 
  poèet krokù posuvu) </FONT></LI></UL>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Rotace: </FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>ROL</STRONG> cíl, 
  poèet - v cíli posuò tak, e kadı niší bit kopíruj do vyššího, nejvyšší 
  kopíruj na místo nejnišího a do registru CF (registr - CL (kterı nese poèet 
  krokù posuvu), registr - 1, [286] registr - poèet krokù posuvu) </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>ROR</STRONG> cíl, 
  poèet - v cíli posuò tak, e kadı vyšší bit kopíruj do nišího, nejniší 
  kopíruj na místo nejvyššího a do registru CF (registr - CL (kterı nese poèet 
  krokù posuvu), registr - 1, [286] registr - poèet krokù posuvu) </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>RCL</STRONG> cíl, 
  poèet - v cíli posuò tak, e kadı niší bit kopíruj do vyššího, nejvyšší 
  kopíruj do registru CF, obsah CF pøenes na místo nejnišího (registr - CL 
  (kterı nese poèet krokù posuvu), registr - 1, [286] registr - poèet krokù 
  posuvu) </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>RCR</STRONG> cíl, 
  poèet - v cíli posuò tak, e kadı vyšší bit kopíruj do nišího, nejniší 
  kopíruj do registru CF, obsah CF pøenes na místo nejvyššího (registr - CL 
  (kterı nese poèet krokù posuvu), registr - 1, [286] registr - poèet krokù 
  posuvu) </FONT></LI></UL>
<H4><A name="Pouití posuvù a rotací"><FONT size=2 face=Arial></FONT></A><FONT 
size=-1 face="Arial CE, Arial, Helvetica">Pouití posuvù a rotací </FONT></H4>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>Kontrola jednotlivıch 
bitù <BR></STRONG>Jestlie potøebujeme zkontrolovat, jakou hodnotu nìkterı z 
bitù nese, staèí slovo nebo slabiku rotovat pøes registr CF. Hodnotu, kterou bit 
nese, potom zjistíme kontrolou registru CF. </FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>Tvorba masky 
<BR></STRONG>Jestlie nevíme, jak vytvoøit slabiku nebo slovo pro vymaskování, 
pouijeme instrukci posuvu. <STRONG>MOV</STRONG>&nbsp;AL, 1; 
<STRONG>SHL</STRONG>&nbsp;AL,&nbsp;3. Takto získáme slabiku s nastavenım bitem 
na ètvrtém místì (00001000). </FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>Celoèíselné dìlení 
mocninou 2 a násobení konstantou <BR></STRONG>Je to nejdùleitìjší pouití 
posuvù. Vychází z faktu, e bitovı posuv èísla doleva o jeden krok je stejnı, 
jako bychom èíslo vynásobili dvìma. Naopak bitovı posuv èísla doprava o jeden 
krok je stejnı, jako bychom èíslo dìlili dvìma. Dìlení: Do registru umístíme 
dìlence. Ten potom posuneme doprava o tolik, kolikátou mocninou 2 je dìlitel: 
</FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>SHR</STRONG> AL, 1 
  - AL := AL div 2 </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>SHR</STRONG> AL, 2 
  - AL := AL div 4 </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>SHR</STRONG> AL, 3 
  - AL := AL div 8 </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>SHR</STRONG> AL, 4 
  - AL := AL div 16 . . . </FONT></LI></UL>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Pozor! Toto dìlení je sice 
velmi rychlé, ale pouitelné jen tehdy, jestlie chceme èíslo dìlit mocninou 2 
(a to bıvá naštìstí nejèastìji). Ke zjištìní zbytku po celoèíselném dìlení 
pouijeme operaci AND (jak bylo popsáno vıše).<BR>Násobení èísla konstantou: Do 
tolika registrù, kolik je log. 1 v binárním vyjádøení konstanty, umístíme 
hodnotu èísla. Potom jednotlivé registry posuneme doleva. Kadı o tolik, na 
kolikátém místì byla log. 1 v binárním vyjádøení konstanty. Nakonec všechny 
registry pøièteme k jedinému, ve kterém bude vısledek. <BR>Pøíklad: Vynásobme 
konstantou 18 vloené èíslo: </FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">18 : 2 = 9 (0)...0 </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">&nbsp;9 : 2 = 4 (1)...1 
  </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">&nbsp;4 : 2 = 2 (0)...2 
  </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">&nbsp;2 : 2 = 1 (0)...3 
  </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">&nbsp;1 : 2 = 0 (1)...4 
  </FONT></LI></UL>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Logická 1 je tedy na místì 
è.1 a è.4. Proto pouijeme dva registry, ty posuneme o 1 a 4 kroky. Nakonec je 
seèteme.</FONT></P>
<P><CODE>{$G+} <BR>var cislo:word; <BR>begin <BR>&nbsp;readln (cislo); 
<BR>&nbsp;asm <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> 
AX,cislo &nbsp;{naber èíslo do prvního registru} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> BX, AX 
&nbsp;&nbsp;&nbsp;{naber èíslo do druhého registru} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>SHL</STRONG></CODE><CODE> AX, 1 
&nbsp;&nbsp;&nbsp;&nbsp;{v prvním registru jednou doleva&lt;=&gt;vynásob 2} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>SHL</STRONG></CODE><CODE> BX, 4 
&nbsp;&nbsp;&nbsp;&nbsp;{v druhém registru ètyøikrát doleva&lt;=&gt;vynásob 16} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>ADD</STRONG></CODE><CODE> AX, 
BX&nbsp;&nbsp; &nbsp;{seèti obsahy obou registrù} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> cislo, AX {vra 
pøes promìnnou cislo} <BR>&nbsp;end; <BR>&nbsp;writeln ('Èíslo*18=',cislo); 
<BR>end. </CODE></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Uvedenı postup mùete snadno 
pøevést na libovolnou konstantu. Vzhledem ke zdlouhavosti násobení instrukcí 
<STRONG>MUL</STRONG> vám tento algoritmus obèas zrychlí program. </FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Následující pøíklad vytváøí 
øetìzec informací o èase. Ten si zjistí z pamìti CMOS. Ètení provádíme tak, e 
na adresu portu $70 vyšleme èíslo ètené slabiky (0 - sekundy, 2 - minuty, 4 - 
hodiny) v CMOS. Z portu $71 potom pøeèteme její hodnotu. Ta je v CMOS ve 
zhuštìném BCD tvaru. Proto ji pøevedeme na nezhuštìnı a teprve potom na kód 
ASCII. Nakonec data zapíši do promìnné slovo typu string ve tvaru, v jakém je 
zvykem èas zapisovat. Program jsem optimalizoval tak, aby mìl co nejmenší poèet 
instrukcí. Vzhledem k tomu, e ve vloeném assembleru jsem nepouil cyklus, 
tvoøím jej s pomocí pascalovského for cyklu. Podobnım zpùsobem bychom èetli i 
jiné uiteèné informace z pamìti CMOS (datum, konfigurace . . .). </FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Pøíklad: </FONT></P>
<P><CODE>uses crt; <BR>var i:byte; <BR>&nbsp;&nbsp;&nbsp;&nbsp;slovo:string; 
<BR>begin <BR>&nbsp;slovo[0]:=#8; 
<BR>&nbsp;slovo[3]:='.';<BR>&nbsp;slovo[6]:='.'; <BR>&nbsp;clrscr; 
<BR>&nbsp;repeat <BR>&nbsp;&nbsp;for i:=0 to 2 do <BR>&nbsp;&nbsp;asm 
<BR>&nbsp;&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> BX,offset 
slovo {naber adresu promìnné slovo do BX} 
<BR>&nbsp;&nbsp;&nbsp;</CODE><CODE><STRONG>XOR</STRONG></CODE><CODE> AH,AH 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{vyma horní 
polovinu registru AX} 
<BR>&nbsp;&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> 
AL,i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {naber do 
dolní poloviny AX krok i} 
<BR>&nbsp;&nbsp;&nbsp;</CODE><CODE><STRONG>SUB</STRONG></CODE><CODE> BX,AX 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{odeèti od BX obsah 
AX} <BR>&nbsp;&nbsp;&nbsp;</CODE><CODE><STRONG>SHL</STRONG></CODE><CODE> AL,1 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{vynásob, 
AL:=AL*2} <BR>&nbsp;&nbsp;&nbsp;</CODE><CODE><STRONG>SUB</STRONG></CODE><CODE> 
BX,AX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {odeèti od BX 
obsah AX} <BR>&nbsp;&nbsp;&nbsp;</CODE><CODE><STRONG>OUT</STRONG></CODE><CODE> 
$70,AL &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{pošli na CMOS 
adresu ètené slabiky} 
<BR>&nbsp;&nbsp;&nbsp;</CODE><CODE><STRONG>IN</STRONG></CODE><CODE> AL,$71 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{pøeèti z CMOS obsah 
ètené slabiky} 
<BR>&nbsp;&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> AH,AL 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{zkopíruj obsah 
pøeètené slabiky do AH} 
<BR>&nbsp;&nbsp;&nbsp;</CODE><CODE><STRONG>SHR</STRONG></CODE><CODE> AH,4 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{desítky posuò 
do dolní poloviny AH} 
<BR>&nbsp;&nbsp;&nbsp;</CODE><CODE><STRONG>AND</STRONG></CODE><CODE> AX,$0F0F 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{odstraò zbyteèné bity} 
<BR>&nbsp;&nbsp;&nbsp;</CODE><CODE><STRONG>OR</STRONG></CODE><CODE> AX,$3030 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{proveï pøevod do ASCII} 
<BR>&nbsp;&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> 8[BX],AL 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{nastav jednotky v promìnné slovo} 
<BR>&nbsp;&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> 7[BX],AH 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{nastav desítky v promìnné slovo} 
<BR>&nbsp;&nbsp;end; <BR>&nbsp;&nbsp;gotoxy (1,1); <BR>&nbsp;&nbsp;write(slovo); 
<BR>&nbsp;until keypressed; <BR>&nbsp;readkey; <BR>end. </CODE></P>
<H3><A name="Instrukce skoku"><FONT 
face="Arial CE, Arial, Helvetica"></FONT></A><FONT size=3 face=Arial>Instrukce 
skoku </FONT></H3>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Protoe si mikroprocesor 
vytváøí frontu instrukcí, nejsou z hlediska rychlosti bìhu programu skoky to 
pravé. Pøesto bychom sloitìjší programy bez nich asi tìko tvoøili. Abychom 
mohli instrukce skoku pouívat, musíme umìt vytvoøit návìští. </FONT></P>
<H4><A name=Návìští><FONT size=-1 
face="Arial CE, Arial, Helvetica"></FONT></A><FONT size=2 face=Arial>Návìští 
</FONT></H4>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Assembler je správnì jen 
název pøekladaèe "Jazyka symbolickıch adres", kterı se pro nìj èassem vil. 
Název "Jazyk symbolickıch adres" vyjadøuje to, e místo adres instrukcí 
pouíváme symboly. V Turbo assembleru nejsme v názvech návìští nijak zvláš 
omezováni. Ve vkládaném assembleru mùeme za název návìští pouít posloupnost 
znakù zaèínající znakem @ (@1, @zacatek, @navesti). Jestlie pouíváme návìští, 
deklarované mimo vkládanı assembler (s pomocí LABEL), není pøítomnost znaku @ 
nutná. Návìští s dvojteèkou uvedeme pøed instrukci, na kterou se odkazujeme. Pøi 
pøekladu je v místech odkazu na návìští jeho název nahrazen skuteènou adresou 
instrukce. </FONT></P>
<H4><A name="Nepodmínìnı skok"><FONT size=-1 
face="Arial CE, Arial, Helvetica"></FONT></A><FONT size=2 face=Arial>Nepodmínìnı 
skok </FONT></H4>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Je to nepodmínìnı skok na 
jiné místo programu. To musí bıt oznaèené návìštím. Za instrukcí skoku je potom 
uveden jeho název. </FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>JMP</STRONG> 
  návìští - proveï skok programu na návìští (ve skuteènosti se jen zmìní obsah 
  èítaèe instrukcí IP, pøípadnì CS pøi vzdáleném skoku) V programu potom 
  nepodmínìnı skok vypadá takto: <BR></FONT><CODE>@navesti: instrukce na kterou 
  bude odkaz <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;. 
  <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;. 
  <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</CODE><CODE><STRONG>JMP</STRONG></CODE><CODE> 
  @navesti </CODE></LI></UL>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Jestlie skoky pouíváme, 
hrozí vdy nebezpeèí, e se program zacykluje (a nikdy neskonèí). Proto je 
dùleité si vdy rozmyslet, za jakıch okolností by k této kolizi mohlo dojít. 
</FONT></P>
<H4><A name="Podmínìnı skok"><FONT size=-1 
face="Arial CE, Arial, Helvetica"></FONT></A><FONT size=2 face=Arial>Podmínìnı 
skok </FONT></H4>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Jedná se o skok podmínìnı 
stavem jednoho nebo více, bitù registru pøíznakù F. Jen tímto zpùsobem je moné 
provádìt v assembleru pøímé vìtvení programu. Pøed instrukcí podmínìného skoku 
proto vdy provedeme instrukci, která pouitı pøíznak nastaví. V pøípadì, e 
není splnìna podmínka skoku, pokraèuje program dál, jako by se nic nedìlo. 
Instrukce podmínìného skoku zaèínají vdy písmenkem J. Za ním je zkratka 
udávající na jakıch bitech registru F je skok závislı. </FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>JE</STRONG> 
  návìští - skok na návìští pøi ZF = 1 </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>JZ</STRONG> 
  návìští - skok na návìští pøi ZF = 1 </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>JNE</STRONG> 
  návìští - skok na návìští pøi ZF = 0 </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>JNZ</STRONG> 
  návìští - skok na návìští pøi ZF = 0 </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>JC</STRONG> 
  návìští - skok na návìští pøi CF = 1 </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>JNC</STRONG> 
  návìští - skok na návìští pøi CF = 0 </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>JS</STRONG> 
  návìští - skok na návìští pøi SF = 1 </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>JNS</STRONG> 
  návìští - skok na návìští pøi SF = 0 </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>JO</STRONG> 
  návìští - skok na návìští pøi OF = 1 </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>JNO</STRONG> 
  návìští - skok na návìští pøi OF = 0 </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>JP</STRONG> 
  návìští - skok na návìští pøi PF = 1 </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>JNP</STRONG> 
  návìští - skok na návìští pøi PF = 0 </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>JPE</STRONG> 
  návìští - skok na návìští pøi PF = 1 </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>JPO</STRONG> 
  návìští - skok na návìští pøi PF = 0 </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>JA</STRONG> 
  návìští - skok na návìští pøi (CF = 0) AND (ZF = 0) </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>JNBE</STRONG> 
  návìští - skok na návìští pøi (CF = 0) AND (ZF = 0) </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>JAE</STRONG> 
  návìští - skok na návìští pøi CF = 0 </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>JNB</STRONG> 
  návìští - skok na návìští pøi CF = 0 </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>JB</STRONG> 
  návìští - skok na návìští pøi CF = 1 </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>JNAE</STRONG> 
  návìští - skok na návìští pøi CF = 1 </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>JBE</STRONG> 
  návìští - skok na návìští pøi (CF = 1) OR (ZF = 1) </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>JNA</STRONG> 
  návìští&nbsp;- skok na návìští pøi (CF = 1) OR (ZF = 1) </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>JG</STRONG> 
  návìští - skok na návìští pøi (ZF = 0) OR (SF = OF) </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>JNLE</STRONG> 
  návìští - skok na návìští pøi (ZF = 0) OR (SF = OF) </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>JGE</STRONG> 
  návìští - skok na návìští pøi SF = OF </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>JNL</STRONG> 
  návìští - skok na návìští pøi SF = OF </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>JL</STRONG> 
  návìští - skok na návìští pøi SF &lt;&gt; OF </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>JNGE</STRONG> 
  návìští - skok na návìští pøi SF &lt;&gt; OF </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>JLE</STRONG> 
  návìští - skok na návìští pøi (ZF = 1) OR (SF &lt;&gt; OF) </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>JNG</STRONG> 
  návìští - skok na návìští pøi (ZF = 1) OR (SF &lt;&gt; OF) </FONT></LI></UL>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Pøi hledání instrukce 
podmínìného skoku musíme myslet na to, za jakıch okolností chceme skok vykonat. 
K tomu je také dobré si uvìdomit: </FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">A &lt; B =&gt; A - B &lt; 
  0 =&gt; SF = 1 </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">A = B =&gt; A - B = 0 
  =&gt; ZF = 1 </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">A &gt; B =&gt; A - B &gt; 
  0 =&gt; SF = 0 </FONT></LI></UL>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Rozdíl èísel v tomto pøípadì 
provedeme nejlépe instrukcí <STRONG>CMP</STRONG>. Pro tvorbu cyklu mùeme pouít 
jeden z registrù, kterı si pro krokovací promìnnou vyèleníme. Jednoduchı cyklus 
pak vytvoøíme podmínìnım skokem: </FONT></P>
<P><CODE>begin <BR>&nbsp;asm 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> CL, 10 {do 
registru CL dosaï 10, poèet krokù} <BR>&nbsp;@nav: 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{návìští, tady umístíme opakovanou èinnost} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>DEC</STRONG></CODE><CODE> CL 
&nbsp;&nbsp;&nbsp;&nbsp;{odeèti od CL èíslo 1} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>JNZ</STRONG></CODE><CODE> @nav 
&nbsp;&nbsp;{jestlie není nula skoè na návìští} <BR>&nbsp;end; <BR>end. 
</CODE></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Program opakuje skok dokud 
není v registru CL nulovı vısledek. </FONT></P>
<H3><A name="Nepodmínìnı a podmínìnı cyklus"><FONT size=3 
face=Arial></FONT></A><FONT face="Arial CE, Arial, Helvetica">Nepodmínìnı a 
podmínìnı cyklus </FONT></H3>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">ASM86 má i pro cyklus 
instrukci. Její pouití však pøedpokládá to, e si rezervujeme registr CX pro 
èítání. Do nìj pøed cyklem umístíme poèet opakování. Instrukce 
<STRONG>LOOP</STRONG> pak cyklus umoní realizovat. </FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>LOOP</STRONG> 
  návìští - od CX odeèti jedna, jestlie je CX&lt;&gt;0 skoè na návìští 
  </FONT></LI></UL>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Pøíklad: </FONT></P>
<P><CODE>uses crt; <BR>var pole:array [0..9] of byte; 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;i:byte; <BR>begin <BR>&nbsp;clrscr; <BR>&nbsp;asm 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>XOR</STRONG></CODE><CODE> DI, DI {nuluj 
registr DI} <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> CX, 
10 {do CX dej délku pole} <BR>&nbsp;@nav: 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{návìští, zaèátek cyklu} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> 
</CODE><CODE><STRONG>BYTE</STRONG></CODE><CODE> 
</CODE><CODE><STRONG>PTR</STRONG></CODE><CODE> [DI+OFFSET pole], cl{pøesuò do 
pole na místo urè. DI} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>INC</STRONG></CODE><CODE> DI 
&nbsp;&nbsp;&nbsp;&nbsp;{na další prvek pole} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>LOOP</STRONG></CODE><CODE> @nav 
&nbsp;{odeèti od CX 1, není-li nula na @nav} <BR>&nbsp;end; <BR>&nbsp;for i:=0 
to 9 do <BR>&nbsp;&nbsp;writeln (pole[i]); <BR>&nbsp;readkey; <BR>end. 
</CODE></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Uvedenı pøíklad naplní pole 
hodnotami 1-10. Obsah v registru CX je pouit ke krokování, a souèasnì se s ním 
plní pole. Prvky pole jsou slabiky. Proto se obsah registru DI zvyšuje o jednu. 
V pøípadì, e by se jednalo o slova, musíme k registru DI pøièítat 2. Cyklu 
vytvoøenému pomocí <STRONG>LOOP</STRONG> se mùeme programovì vyhnout instrukcí 
<STRONG>JCXZ</STRONG> návìští - jestlie je v CX nula pøesuò se na návìští. 
</FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Pøíklad: </FONT></P>
<P><CODE>uses crt; <BR>var pole1,pole2:array [0..9] of byte; 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;i:byte; <BR>&nbsp;&nbsp;&nbsp;&nbsp;pocet:word; 
<BR>begin <BR>&nbsp;clrscr; <BR>&nbsp;repeat {vstup poètu prvkù kopie s 
kontrolou hodnoty poèet} <BR>&nbsp;&nbsp;write ('Zadej pocet kopirovanych prvku 
(0..10):'); <BR>&nbsp;&nbsp;{$I-}readln (pocet);{$I+} <BR>&nbsp;until 
(ioresult=0) and (pocet in [0..10]); <BR>&nbsp;randomize; <BR>&nbsp;for i:=0 to 
9 do <BR>&nbsp;begin 
<BR>&nbsp;&nbsp;pole1[i]:=random(256);<BR>&nbsp;&nbsp;pole2[i]:=random(256); 
<BR>&nbsp;end; <BR>&nbsp;asm 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> CX, pocet 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{do registru CX dej poèet prvkù kopie} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>JCXZ</STRONG></CODE><CODE> @konec 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{jestlie je nulovı jdi na 
konec} <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> SI, 
</CODE><CODE><STRONG>OFFSET</STRONG></CODE><CODE> pole1 {naber adresu pole1} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> DI, 
</CODE><CODE><STRONG>OFFSET</STRONG></CODE><CODE> pole2 {naber adresu pole2} 
<BR>&nbsp;@cykl: 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{zaèátek 
cyklu} <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> AL, [SI] 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{do registru AL pøesuò prvek z 
pole1} <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> [DI], AL 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{z registru AL pøesuò prvek do 
pole2} <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>INC</STRONG></CODE><CODE> SI 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{posuò 
se na další prvek v polích} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>INC</STRONG></CODE><CODE> DI 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>LOOP</STRONG></CODE><CODE> @cykl 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{sni CX o jednu, 
jestli je rùzné od nuly} 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{skok 
na @cykl} <BR>&nbsp;@konec: 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{konec 
bloku asm} <BR>&nbsp;end; <BR>&nbsp;for i:=0 to 9 do <BR>&nbsp;&nbsp;writeln 
(pole1[i],'..',pole2[i]); <BR>&nbsp;readkey; <BR>end. </CODE></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">A dosud jsme za podmínku 
opakování povaovali nenulové èíslo v registru CX. ASM86 však umoòuje podmínky 
opakování obohatit testováním pøíznaku ZF. </FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>LOOPE</STRONG> 
  návìští &lt;=&gt; <STRONG>LOOPZ</STRONG> návìští - sni CX o jednu a pøesuò se 
  na návìští pøi (CX &lt;&gt; 0) AND (ZF = 1) </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>LOOPNE</STRONG> 
  návìští &lt;=&gt; <STRONG>LOOPNZ</STRONG> návìští&lt;=&gt; LOOP návìští - sni 
  CX o jednu a pøesuò se na návìští pøi (CX &lt;&gt; 0) AND (ZF = 0) 
</FONT></LI></UL>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Pøi pouití tìchto instrukcí 
dáváme v programu monost uniknout z cyklu i nastavením pøíznaku ZF. Nezapomeòte 
ale, e ZF se musí pøed koncem cyklu opìt nastavit vhodnou instrukcí. 
</FONT></P>
<H3><A name="Nastavení registru pøíznakù"><FONT size=3 
face=Arial></FONT></A><FONT face="Arial CE, Arial, Helvetica">Nastavení registru 
pøíznakù </FONT></H3>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Registr pøíznakù se èásteènì 
nastavuje souèasnì s vykonáváním nìkterıch instrukcí. Obsahuje ale i registry, 
které se automaticky nenastavují (IF, DF, TF). Proto ASM86 má instrukce, kterımi 
mùeme pøímo ovlivnit hodnoty nìkterıch bitù registru F. </FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>CLC</STRONG> - do 
  registru CF vlo hodnotu log. 0 </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>CMC</STRONG> - 
  neguj obsah registru CF </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>STC</STRONG> - do 
  registru CF vlo hodnotu log. 1 </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>CLD</STRONG> - do 
  registru DF vlo hodnotu log. 0 (DI, SI pøi práci s øetìzci zvyšuj) </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>STD</STRONG> - do 
  registru DF vlo hodnotu log. 1 (DI, SI pøi práci s øetìzci sniuj) </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>CLI</STRONG> - do 
  registru IF vlo hodnotu log. 0 (zaka pøerušení) </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>STI</STRONG> - do 
  registru IF vlo hodnotu log. 1 (povol pøerušení) </FONT></LI></UL>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Jestlie chceme nastavit 
hodnotu v pøíznaku, pro kterı instrukce neexistuje, pouijeme algoritmus: 
</FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">registr F pøedáme pøes 
  zásobník do nìkterého z registrù pro všeobecné pouití </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">v tomto registru logickou 
  operací nastavíme bit pøíznaku </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">pøes zásobník opìt pøedáme 
  obsah registru do registru F </FONT></LI></UL>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Pøíklad: </FONT></P>
<P><CODE>var promenna:byte; <BR>begin <BR>&nbsp;asm 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> promenna,0 
&nbsp;{nastav promìnnou do hodnoty 0} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>PUSHF</STRONG></CODE><CODE> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ulo registr 
pøíznakù do zásobníku} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>POP</STRONG></CODE><CODE> AX 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{pøesuò obsah vrcholku 
zásobníku do registru AX} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>OR</STRONG></CODE><CODE> AX,1 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{nastav poslední bit (CF) do 
logické 1} <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>PUSH</STRONG></CODE><CODE> AX 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ulo obsah AX do zásobníku} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>POPF</STRONG></CODE><CODE> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{pøesuò 
nazpátek do registru pøíznakù} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>JNC</STRONG></CODE><CODE> @konec 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{otestuj nastavení CF} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> promenna,1 
&nbsp;{CF byl v 1, nastav hodnotu promìnné do 1} <BR>&nbsp;@konec: 
<BR>&nbsp;end; <BR>&nbsp;writeln (promenna); {vypiš obsah promìnné} 
<BR>end.</CODE></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Jednotlivé bity èásti 
registru pøíznakù mùeme také ovlivnit vhodnım pouitím instrukcí 
<STRONG>LAHF</STRONG> a <STRONG>SAHF</STRONG>. </FONT></P>
<H3><A name="Vyèlenìní pamìti pro promìnné v bloku asm"><FONT size=3 
face=Arial></FONT></A><FONT face="Arial CE, Arial, Helvetica">Vyèlenìní pamìti 
pro promìnné v bloku asm </FONT></H3>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Ne vdy je vhodné pouívat 
pro naše promìnné pamì hlavního programu. Monost vyèlenit si nìkolik slabik 
dává i vloenı assembler. Ve skuteènosti se jedná o èást pamìti urèenou pro 
strojovı kód. My si ale do ní umístíme hodnoty, na které vìtšinou nezbylo místo 
v registrech. Protoe je tento blok v segmentu programu, musíme tento blok 
promìnnıch programovì obejít. Mikroprocesor by toti tyto hodnoty v pamìti 
povaoval za instrukce. Vyèlenit místo si mùeme pomocí direktiv: </FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>DB</STRONG> - zde 
  vyèleò slabiky (8 bitù, hodnoty -128-255) </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>DW</STRONG> - zde 
  vyèleò slova (16 bitù, hodnoty -32 768-65 535) </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>DD</STRONG> - zde 
  vyèleò dvojslova (32bitù, hodnoty -2 147 483 648-4 294 967 295) 
</FONT></LI></UL>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Za direktivu povaujeme 
pøíkaz pro pøekladaè, není to tedy instrukce. S pomocí tìchto direktiv øíkáme 
pøekladaèi, aby v kódu programu rezervoval urèitı poèet slabik pro naše úèely. 
Za tyto direktivy rovnou píšeme poèáteèní hodnoty slabik, slov a dvojslov 
oddìlené èárkou. Pokud napíšeme jméno promìnné deklarované pomocí var nebo jméno 
procedury, jedná se o jejich adresy (za direktivou <STRONG>DW</STRONG> offsetová 
èást adresy, za direktivou <STRONG>DD</STRONG> celá adresa, tedy ukazatel). Pro 
názornost si rovnou uvedeme program s tìmito direktivami. </FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Pøíklad: </FONT></P>
<P><CODE>var promenna:byte; <BR>begin <BR>&nbsp;asm 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>JMP</STRONG></CODE><CODE> @dal 
<BR>&nbsp;@slabiky: 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>DB</STRONG></CODE><CODE> 10, 200,'M','Ahoj' 
<BR>&nbsp;@slova: <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>DW</STRONG></CODE><CODE> 
32000,'A',promenna <BR>&nbsp;@dvojslova: 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>DD</STRONG></CODE><CODE> promenna 
<BR>&nbsp;@dal: <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> 
AL, CS:[</CODE><CODE><STRONG>OFFSET</STRONG></CODE><CODE> @slabiky] 
&nbsp;&nbsp;{do AL pøesuò slabiku z adresy} 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@slabiky, 
AL:=10} <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> AL, 
CS:[</CODE><CODE><STRONG>OFFSET</STRONG></CODE><CODE> @slabiky+1] {do AL pøesuò 
slabiku} 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{z 
@slabiky+1, AL:=200} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> AL, 
CS:[</CODE><CODE><STRONG>OFFSET</STRONG></CODE><CODE> @slabiky+2] {do AL pøesuò 
hodnotu ASCII} 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{znaku 
'M'} <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> AL, 
CS:[</CODE><CODE><STRONG>OFFSET</STRONG></CODE><CODE> @slabiky+3] {do AL pøesuò 
ASCII prvního znaku} 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{øetìzce 
'Ahoj'} <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> AL, 
CS:[</CODE><CODE><STRONG>OFFSET</STRONG></CODE><CODE> @slabiky+4] {do AL pøesuò 
ASCII druhého znaku} 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{øetìzce 
'Ahoj'} <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> AX, 
CS:[</CODE><CODE><STRONG>OFFSET</STRONG></CODE><CODE> @slova] 
&nbsp;&nbsp;&nbsp;&nbsp;{do AX pøesuò slovo z adresy} 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@slova, 
AX:=32000} <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> AX, 
CS:[</CODE><CODE><STRONG>OFFSET</STRONG></CODE><CODE> @slova+2] &nbsp;&nbsp;{do 
AX pøesuò hodnotu ASCII znaku} 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{'A', 
AH:=0,AL:=65} <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> BX, 
CS:[</CODE><CODE><STRONG>OFFSET</STRONG></CODE><CODE> @slova+4] &nbsp;&nbsp;{do 
BX pøesuò offset promìnné} 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{promenna} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> 
</CODE><CODE><STRONG>BYTE</STRONG></CODE><CODE> 
</CODE><CODE><STRONG>PTR</STRONG></CODE><CODE> [BX], AL 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{do této promìnné zapiš 
obsah} 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{registru 
AL} <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>LES</STRONG></CODE><CODE> 
BX,CS:[</CODE><CODE><STRONG>OFFSET</STRONG></CODE><CODE> @dvojslova]&nbsp; 
{naber obsah ukazatele, tedy} 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{celou 
adresu promìnné do ES:BX} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>SEGES</STRONG></CODE><CODE> 
</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> 
</CODE><CODE><STRONG>BYTE</STRONG></CODE><CODE> PTR [BX], AL 
&nbsp;&nbsp;&nbsp;{na celou adresu promìnné zapiš} 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{obsah 
AL} <BR>&nbsp;end; <BR>end. </CODE></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Na takto vytvoøená místa 
mùeme samozøejmì i zapisovat. Pokud nechceme pouívat návìští pro kadou èást, 
staèí si jen pamatovat, kolik místa zabere slabika, slovo, nebo dvojslovo. Potom 
se na hledanou èást dostaneme pøièítáním, nebo odèítáním urèitıch hodnot k 
offsetu návìští. Zajímavé je i vyuití adres promìnnıch. Protoe promìnná za 
direktivou <STRONG>DD</STRONG> je celá adresa, mùeme naplnit instrukcí 
<STRONG>LES</STRONG> (<STRONG>LDS</STRONG>) oba registry, tedy segment i offset. 
Pokud zapíšeme <STRONG>DB</STRONG> 4, 'Ahoj', jedná se o klasickı pascalovskı 
øetìzec z délkou na zaèátku. </FONT></P>
<H3><A name="Instrukce pro práci s øetìzci"><FONT size=3 
face=Arial></FONT></A><FONT face="Arial CE, Arial, Helvetica">Instrukce pro 
práci s øetìzci </FONT></H3>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">ASM86 má velmi silnı nástroj 
v øetìzcovıch instrukcích. Za øetìzec je zde na rozdíl od Pascalovského 
povaován blok dat v pamìti o témìø libovolné délce (podle definice jsme omezeni 
jen velikostí segmentu, to se ale dá snadno obejít). Pro pouití øetìzcovıch 
instrukcí jsou vyèlenìny dvojice registrù, které nesou adresy: </FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">DS:SI - pro adresu 
  zdrojového øetìzce </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">ES:DI - pro adresu 
  cílového øetìzce </FONT></LI></UL>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">V praxi to znamená, e vdy 
jeden blok v pamìti je oznaèen za zdrojovı, druhı za cílovı. Dùleitou roli zde 
hrají i registry:</FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">CX - nese délku øetìzce 
  </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">DF - urèuje smìr 
  zpracování øetìzcù (0 - adresy se zvyšují, 1 - adresy se sniují) 
</FONT></LI></UL>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Øetìzové instrukce pak jsou 
</FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>LODSB</STRONG> 
  (<STRONG>LODSW</STRONG>) - pøesuò z adresy DS:SI do registru AL (AX) a zvyš SI 
  o jednu (o dvì) </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>STOSB</STRONG> 
  (<STRONG>STOSW</STRONG>) - pøesuò z registru AL (AX) na adresu ES:DI a zvyš DI 
  o jednu (o dvì) </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>MOVSB</STRONG> 
  (<STRONG>MOVSW</STRONG>) - pøesuò z adresy DS:SI slabiku (slovo) na adresu 
  ES:DI a SI, DI zvyš o jednu (o dvì) </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>CMPSB</STRONG> 
  (<STRONG>CMPSW</STRONG>) - porovnej (odeèti) slabiku (slovo) na adrese DS:SI 
  se slabikou (slovem) na adrese ES:DI, podle vısledku nastav pøíznaky (ZF = 1 
  pøi shodì, ZF = 0 pøi neshodì), potom zvyš adresy SI a DI o jednu (o dvì) 
  </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>SCASB</STRONG> 
  (<STRONG>SCASW</STRONG>) - porovnej (odeèti) slabiku z adresy ES:DI z 
  registrem AL (AX), podle vısledku nastav pøíznaky (ZF = 1 pøi shodì, ZF = 0 
  pøi neshodì), potom zvyš adresu DI o jednu (o dvì) </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>INSB</STRONG> 
  (<STRONG>INSW</STRONG>) - [286], pøesuò z portu s adresou v DX do pamìti s 
  adresou ES:DI slabiku (slovo) a adresu DI zvyš o jednu (o dvì) </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>OUTSB</STRONG> 
  (<STRONG>OUTSW</STRONG>) - [286], pøesuò z pamìti s adresou DS:SI slabiku 
  (slovo) na port urèenı adresou v DX a zvyš adresu SI o jednu (o dvì) 
  </FONT></LI></UL>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Slovo zvıšit v tìchto 
popisech èinnosti nahradíme slovem sníit pøi DF = 1. Tyto instrukce umoní 
najednou provést urèitou èinnost a pøitom aktualizují adresy podle stavu DF a 
podle toho, jestli pracujeme se slabikami nebo slovy. </FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Následující pøíklad vyuívá 
pøímého zápisu do videopamìti (VRAM) v textovém reimu VGA k vıstupu 
pascalovského øetìzce. VRAM, zaèíná na adrese $B8000. Je organizovaná jako pole 
slov nesoucích informace o zobrazovanıch znacích. Kadé slovo nese slabiku 
atributù (barva znaku a jeho pozadí) a slabiku s ASCII kódem zobrazeného znaku. 
80 slov VRAM je jeden øádek na obrazovce. Proto pøi zvıšení adresy $B8000 o 160 
mùeme pracovat s druhım øádkem atd. </FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Pøíklad: </FONT></P>
<P><CODE>var slovo:string; <BR>begin <BR>&nbsp;slovo:='Ahoj'; <BR>&nbsp;asm 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>PUSH</STRONG></CODE><CODE> DS 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ulo obsah DS do zásobníku, budeme ho 
mìnit} <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>JMP</STRONG></CODE><CODE> 
@dal&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;{obejdi data} <BR>&nbsp;@vram: 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>DW</STRONG></CODE><CODE> $0000,$B800 
{offset:segment VRAM, Pozor! je to obrácenì} <BR>&nbsp;@adsl: 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>DD</STRONG></CODE><CODE> 
slovo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {adresa slova, ukazatel na nìj} 
<BR>&nbsp;@dal: 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{zaèátek programu} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>LDS</STRONG></CODE><CODE> 
SI,CS:[</CODE><CODE><STRONG>OFFSET</STRONG></CODE><CODE> @adsl] {DS:SI nasmìruj 
na zdroj (na slovo)} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>LES</STRONG></CODE><CODE> 
DI,CS:[</CODE><CODE><STRONG>OFFSET</STRONG></CODE><CODE> @vram] {ES:DI nesmìruj 
na VRAM} <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>XOR</STRONG></CODE><CODE> CH,CH 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{nuluj CH} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> CL,[SI] 
&nbsp;&nbsp;&nbsp;{do CL dej délku øetìzce slovo, 1. slabiku} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>INC</STRONG></CODE><CODE> SI 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{posuò se za slabiku s délkou} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> AH,$6F 
&nbsp;&nbsp;&nbsp;&nbsp;{do AH dej atributy nápisu} <BR>&nbsp;@cyk: 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{cyklus pro znak po 
znaku} <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>LODSB</STRONG></CODE><CODE> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{naber kód znaku z øetìzce 
do AL a zvyš SI+1} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>STOSW</STRONG></CODE><CODE> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ulo obsah AX do VRAM, 
zvyš DI+2} <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>LOOP</STRONG></CODE><CODE> @cyk 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{sni CX o jednu, není-li nula jdi na @cyk} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>POP</STRONG></CODE><CODE> DS 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{vra registr DS do pùvodního 
stavu} <BR>&nbsp;end; <BR>end. </CODE></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Uvedenı program zmìní slabiku 
na slovo v registru AX s tím, e bude kód znaku doplnìn o atributy. Jestlie 
zmìníme hodnotu v AH ovlivníme tím barvu vıstupu. </FONT></P>
<H4><A name="Prefix opakování"><FONT size=-1 
face="Arial CE, Arial, Helvetica"></FONT></A><FONT size=2 face=Arial>Prefix 
opakování</FONT></H4>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Dosud známe jen prefix 
pøeskoèení. Prefix opakování se pouívá pøed øetìzcovımi instrukcemi a umoòuje 
tak jejich podmínìné i nepodmínìné opakování. Jejich pouitím zrychlíme a 
zjednodušíme program. Nepodmínìnım prefixem je </FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>REP</STRONG> 
  instrukce - opakuj instrukci tolikrát, kolik je uvedeno v registru CX (CX := 
  CX - 1, opakuj dokud CX &lt;&gt; 0) </FONT></LI></UL>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Tento prefix píšeme vìtšinou 
pøed instrukci <STRONG>MOVSB</STRONG> (<STRONG>MOVSW</STRONG>). Jestlie máme 
nastavenı registr CX na poèet prvkù øetìzce a adresové registry zdrojového a 
cílového øetìzce, zajistí <STRONG>REP</STRONG> jejich zkopírování na jednom 
øádku programu (napø. <STRONG>REP</STRONG> <STRONG>MOVSB</STRONG>). </FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Pøíklad: </FONT></P>
<P><CODE>var slovo1,slovo2:string; <BR>begin <BR>&nbsp;slovo1:='Ahoj'; 
<BR>&nbsp;asm <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>PUSH</STRONG></CODE><CODE> 
DS&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ulo do zásobníku 
obsah DS, zmìníme ho} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>JMP</STRONG></CODE><CODE> 
@dal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;{skoè na zaèátek, obejdi 
data} <BR>&nbsp;@adr: 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>DD</STRONG></CODE><CODE> slovo1,slovo2 
{definice ukazatelù na pole} <BR>&nbsp;@dal: 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>LDS</STRONG></CODE><CODE> 
SI,CS:[</CODE><CODE><STRONG>OFFSET</STRONG></CODE><CODE> @adr] 
&nbsp;&nbsp;{naber adresu zdrojového øetìzce} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>LES</STRONG></CODE><CODE> 
DI,CS:[</CODE><CODE><STRONG>OFFSET</STRONG></CODE><CODE> @adr+4] {naber adresu 
cílového øetìzce} <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>XOR</STRONG></CODE><CODE> 
CH,CH 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{nuluj 
CH} <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> CL,[SI] 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{do 
CL dej délku øetìzce} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>INC</STRONG></CODE><CODE> CX 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{pascalovskı 
øetìzec nese o slabiku více} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>REP</STRONG></CODE><CODE> 
</CODE><CODE><STRONG>MOVSB</STRONG></CODE><CODE> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{kopíruj 
øetìzce po slabikách} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>POP</STRONG></CODE><CODE> DS 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{vra 
obsah DS ze zásobníku} <BR>&nbsp;end; <BR>&nbsp;writeln (slovo1,' ',slovo2); 
<BR>&nbsp;readln; <BR>end. </CODE></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">V pøíkladu kopírujeme jen 
tolik prvkù, kolik má zdrojové slovo slabik. Tuto informaci si zjistíme z první 
slabiky promìnné slovo1. K tomu musíme ještì pøièíst 1, protoe pascalovskı 
øetìzec nese navíc informaci o délce. I kdy veškeré pøesuny se odehrávají v 
datovém segmentu s adresou v DS, je dobré si zvyknout na to, e vdy, kdy 
mìníme DS, ukládáme jeho obsah pro jistotu do zásobníku. </FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Øetìzcové instrukce vyhledání 
a porovnání vyuívají registr pøíznakù ZF. Proto ASM86 obsahuje navíc prefixy 
podmínìného opakování: </FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>REPE</STRONG> 
  instrukce &lt;=&gt; <STRONG>REPZ</STRONG> instrukce - opakuj tolikrát, kolik 
  je v registru CX a dokud je ZF = 1 (CX := CX - 1, zopakuj pokud je (CX 
  &lt;&gt; 0) AND (ZF = 1)) </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>REPNE</STRONG> 
  instrukce &lt;=&gt; <STRONG>REPNZ</STRONG> instrukce - opakuj tolikrát, kolik 
  je v registru CX a dokud je ZF = 0 (CX := CX - 1, zopakuj pokud je (CX 
  &lt;&gt; 0) AND (ZF = 0)) Opakování je tedy pøerušeno nejen pøi nulovém CX, 
  ale i pøi nastavení ZF do log. 1 nebo 0. </FONT></LI></UL>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Pøíklad: </FONT></P>
<P><CODE>uses crt; <BR>var pole:array [0..9] of word; 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;hledany,pozice:word; 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;i:byte; <BR>begin <BR>&nbsp;clrscr; 
<BR>&nbsp;randomize; <BR>&nbsp;for i:=0 to 9 do 
<BR>&nbsp;&nbsp;pole[i]:=random(65535); &nbsp;&nbsp;{do pole náhodná èísla} 
<BR>&nbsp;hledany:=pole[random(10)]; {vyber hledané èíslo} <BR>&nbsp;writeln 
('Hledam:',hledany); <BR>&nbsp;asm 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>JMP</STRONG></CODE><CODE> @zac 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{skok 
na zaèátek} <BR>&nbsp;@adr: 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>DD</STRONG></CODE><CODE> pole 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{definice 
ukazatele na pole} <BR>&nbsp;@zac: 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> AX,hledany 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{do AX vlo 
hledané èíslo} <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> 
CX,10 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{do 
CX vlo délku øetìzce (pole)} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>LES</STRONG></CODE><CODE> 
DI,CS:[</CODE><CODE><STRONG>OFFSET</STRONG></CODE><CODE> @adr] 
&nbsp;&nbsp;{naber adresu øetìzce} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>REPNE</STRONG></CODE><CODE> SCASW 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{opakuj 
do shody porovnání} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> pozice,9 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{spoèítej 
kolikátı je hledanı,} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>SUB</STRONG></CODE><CODE> pozice,CX 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{k tomu 
pouiješ to, co zbylo v CX} <BR>&nbsp;end; <BR>&nbsp;for i:=0 to 9 do 
<BR>&nbsp;begin <BR>&nbsp;&nbsp;if i&lt;&gt;pozice then textcolor(15) else 
textcolor(12); <BR>&nbsp;&nbsp;writeln (pole[i]); <BR>&nbsp;end; 
<BR>&nbsp;readkey; <BR>end. </CODE></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Tento program vyhledá slovo v 
poli. K tomu slouí jen øádek <STRONG>REPNE</STRONG> <STRONG>SCASW</STRONG>. Ten 
opakuje pohyb po poli, dokud nenajde shodu s hodnotou v registru AX (ta se 
projeví nastavením ZF do 1) . K zjištìní pozice hledaného dobøe poslouí zbytek 
v registru CX. Kdyby byl zbytek nulovı, hledanı prvek by v poli nebyl. 
</FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Pøíklad:</FONT></P>
<P><CODE>uses crt; <BR>var slovo1,slovo2:string; 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;ukazatel:pointer; 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;i,misto,delka:word; <BR>begin 
<BR>&nbsp;slovo1:='Nazdar programátoøi! '+ 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'Zkuste vyhledat 
nìjaké slovo z této vìty.'; <BR>&nbsp;slovo2:='slovo'; 
<BR>&nbsp;delka:=length(slovo2); <BR>&nbsp;asm 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>PUSH</STRONG></CODE><CODE> 
DS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
{ulo DS, budeme ho mìnit} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>JMP</STRONG></CODE><CODE> @dal&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{pøeskoè 
data} <BR>&nbsp;@ukp: 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>DD</STRONG></CODE><CODE> slovo1,slovo2 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ukazatele na øetìzce} 
<BR>&nbsp;@dal: <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>LDS</STRONG></CODE><CODE> 
SI,CS:[</CODE><CODE><STRONG>OFFSET</STRONG></CODE><CODE> @ukp] &nbsp;{naber 
adresu zdroje} <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>INC</STRONG></CODE><CODE> 
SI&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{pøeskoè 
délku øetìzce} <BR>&nbsp;@cyk: 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>LES</STRONG></CODE><CODE> 
DI,CS:[</CODE><CODE><STRONG>OFFSET</STRONG></CODE><CODE> @ukp+4]{naber adresu 
cíle, hledaného slova} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>INC</STRONG></CODE><CODE> DI 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{pøeskoè 
slabiku s délkou øetìzce} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> CX,delka 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{do CX 
vlo délku øetìzce} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>REPE</STRONG></CODE><CODE> 
</CODE><CODE><STRONG>CMPSB</STRONG></CODE><CODE> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{opakuj 
do neshody (konce hledaného)} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>JZ</STRONG></CODE><CODE> @konec 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{byla 
shoda tak na konec} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>SUB</STRONG></CODE><CODE> SI,delka 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{nebyla 
shoda tak se v SI vra} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>INC</STRONG></CODE><CODE> SI 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>ADD</STRONG></CODE><CODE> SI,CX 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{k 
návratu v SI pouij zbytek v CX} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>JMP</STRONG></CODE><CODE> @cyk 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{a 
znovu hledat} <BR>&nbsp;@konec: 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>POP</STRONG></CODE><CODE> DS 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{vra 
obsah DS, u ho nebudeme mìnit} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> misto,SI 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{vypoèítej 
místo v prohledávaném} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> 
SI,CS:[</CODE><CODE><STRONG>OFFSET</STRONG></CODE><CODE> @ukp]&nbsp; {k tomu 
pouiješ délku øetìzce zdroje} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>ADD</STRONG></CODE><CODE> SI,delka 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{délku 
cíle, tedy hledaného} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>SUB</STRONG></CODE><CODE> misto,SI 
<BR>&nbsp;end; <BR>&nbsp;clrscr; <BR>&nbsp;for i:=1 to length(slovo1) do 
<BR>&nbsp;begin <BR>&nbsp;&nbsp;if not(i in [misto..misto+delka-1]) then 
<BR>&nbsp;&nbsp;&nbsp;textcolor (15) 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else 
<BR>&nbsp;&nbsp;&nbsp;textcolor(12); <BR>&nbsp;&nbsp;write(slovo1[i]); 
<BR>&nbsp;end; <BR>&nbsp;readkey; <BR>end. </CODE></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">V pøíkladu prohledáváme 
øetìzec slovo1. Hledáme v nìm umístìní podøetìzce slovo2. Program má dva cykly v 
sobì. První zajišuje pohyb po prohledávaném øetìzci v pøípadì neshody (je 
realizován <STRONG>JMP</STRONG>). Druhı vnitøní zajišuje pohyb po prohledávaném 
s kontrolou s hledanım (je realizován <STRONG>REPE</STRONG>). V pøípadì shody je 
po cyklu <STRONG>REPE</STRONG> v registru ZF = 1 (prostì nevyskoèil neshodou ale 
nulou v CX=&gt; konec hledaného slova a shoda). Proto cyklus prohledávání 
ukonèíme podmínìnım skokem JZ na konec. Zde ze zjistí adresa v prohledávaném 
øetìzci. To je ale adresa za posledním znakem shody. Proto se vrátíme nazpátek o 
délku slova (tam je hledané slovo). </FONT></P>
<H3><A name="Nedokumentované instrukce"><FONT size=3 face=Arial></FONT></A><FONT 
face="Arial CE, Arial, Helvetica">Nedokumentované instrukce</FONT></H3>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Kdy firma Intel navrhovala 
mikroprocesor 8086, byly vloeny do instrukèního souboru i instrukce, které 
nebyly oficiálnì uvedeny v tabulkách. Pøesto je metodou pokusù programátoøi 
objevili. Ve svıch programech mùeme tyto instrukce pouívat. Máme však 
následující omezení:</FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">Pøekladaèe assembleru tyto 
  instrukce neznají, proto je do programu vloíme napøíklad 
  následovnì:<BR><STRONG>DB</STRONG> $D4, 10. Kde <STRONG>DB</STRONG> je 
  definice slabiky (libovolné), $D4 je kód instrukce, která má jeden operand, 
  nyní hotnotu 10. Èást <STRONG>DB</STRONG> v tomto pøípadì samozøejmì 
  neobcházíme <STRONG>JMP</STRONG>, necháme jí tedy provést, jakoby se jednalo o 
  program.</FONT> 
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">Do budoucnosti není 
  zaruèena funkènost tìchto instrukcí na novıch procesorech øady 86.</FONT> 
</LI></UL>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Seznam a funkci pro nás 
pouitelnıch nedokumentovanıch instrukcí najdete v </FONT><A 
href="http://www.mujweb.cz/www/j_schwarz/inssou86.html#Nedokumentovan%E9%20instrukce"><FONT 
size=2 face=Arial>tabulce instrukcí</FONT></A><FONT size=2 
face=Arial>.</FONT></P>
<H3><A name="Volání podprogramù"><FONT 
face="Arial CE, Arial, Helvetica"></FONT></A><FONT size=3 face=Arial>Volání 
podprogramù </FONT></H3>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">V úvodu jsem upozornil na to, 
e vyuití vkládaného assembleru je v tvorbì podprogramù. Pøedem si ale musíme 
ukázat, jak se podprogramy volají. </FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Volání podprogramu spoèívá v 
uloení parametrù do zásobníku a zmìnì adresy v registru IP (èítaè instrukcí) na 
adresu podprogramu s tím, e je uschována adresa odkud provádíme volání (to aby 
procesor vìdìl kam se má vrátit). Parametry do zásobníku ukládáme my, zbytek 
zaøídí instrukce <STRONG>CALL</STRONG>. </FONT></P>
<H4><FONT size=-1 face="Arial CE, Arial, Helvetica">Ukládání parametrù do 
zásobníku </FONT></H4>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">V hlavièce procedury (nebo 
funkce) najdeme témìø vdy definici parametrù volanıch: </FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">hodnotou - podprogram 
  jejich hodnoty pouze vyuívá </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">odkazem - podprogram je 
  mùe èíst a mùe do nich i zapsat </FONT></LI></UL>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Napøíklad: 
</FONT><CODE>procedure soucet (a,b:word;var c:word);</CODE><FONT size=-1 
face="Arial CE, Arial, Helvetica"> je definice procedury s názvem souèet s 
parametry a, b volanımi hodnotou a c volanım odkazem. Pøi volání této procedury 
z nìkteré èásti programu psaném v Pascalu na místa a, b zapíšeme konkrétní 
hodnoty (nebo promìnné (ty ale podprogram nezmìní) s tìmito hodnotami) a na 
místo c zapíšeme promìnnou, ve které najdeme hodnotu po provedení procedury 
(napø. </FONT><CODE>soucet (1,3,promenna_c);</CODE><FONT size=2 face=Arial>). Z 
místa volání pøedáváme parametry do podprogramù vdy pøes zásobník v poøadí 
definice v hlavièce podprogramu. Do zásobníku pøed voláním procedury ukládáme 
odlišnì u parametrù volanıch hodnotou a odkazem. </FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>Pøi volání 
  hodnotou <BR></STRONG>Uloíme konkrétní hodnoty (pøeètené tøeba i z pamìti). 
  Vzhledem k organizaci zásobníku jsou parametry volané hodnotou uloeny po 
  slovech následovnì: </FONT>
  <UL>
    <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">parametry o délce jedné 
    slabiky (byte, shortint, char, boolean) - obsadí celé slovo (pamìtí nešetøí) 
    </FONT>
    <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">parametry o délce 
    jednoho slova (word, integer) - obsadí slovo </FONT>
    <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">parametry o délce 
    dvojslova (pointer, longint) - obsadí dvì slova (ukazatel je adresa, do 
    zásobníku tedy napøed uloíme segmentovou a pak offsetovou èást adresy) 
    </FONT>
    <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">parametry o délce 6 
    slabik (real) - obsadí v zásovníku tøi slova </FONT>
    <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">parametry delší 
    (øetìzce, mnoina, pole, záznamy) - se ukládají jako ukazatele na hodnotu. 
    </FONT></LI></UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>Pøi volání odkazem 
  <BR></STRONG>Uloíme celou adresu místa (tedy segment i offset) odkud se má 
  hodnota èíst nebo kam se má zapsat (to je vlastnì obsah ukazatele na pamìové 
  místo). </FONT></LI></UL>
<H4><FONT size=-1 face="Arial CE, Arial, Helvetica">Samotné volání 
podprogramu</FONT></H4>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Musíme rozlišovat volání 
blízkého podprogramu a vzdáleného. Za vzdálenı v tomto pøípadì povaujeme 
podprogram s adresou v odlišném segmentu. I kdy se pro programátora nic nemìní 
je dobré vìdìt, e pøi vzdáleném volání se mìní nejen IP, ale i CS. Oznaèení 
místa skoku nese tedy navíc informaci o segmentové adrese. Skok do podprogramu 
zajistí instrukce </FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica"><STRONG>CALL</STRONG> 
  adresa - na vrchol zásobníku ulo obsah (CS pøi vzdáleném volání a) IP a naplò 
  tyto registry adresou uvedenou v parametru (pro nás slovo adresa nahradíme 
  názvem podprogramu) </FONT></LI></UL>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Ukonèení samotného 
podprogramu zajistí instrukce </FONT></P>
<UL>
  <LI><FONT size=-1 
  face="Arial CE, Arial, Helvetica"><STRONG>RET</STRONG>[<STRONG>F</STRONG>] - z 
  vrcholu zásobníku vezmi adresy a dosaï je do (CS a) IP Volání podprogramù je 
  tedy jednoduché. </FONT></LI></UL>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Jednoduše napíšeme instrukci 
<STRONG>CALL</STRONG> se jménem podprogramu (tedy procedury nebo funkce). 
Ostatní zaøídí pøekladaè, kterı zjistí, jestli se jedná o blízké nebo vzdálené 
volání. Podle toho dosadí adresu. Návrat si opìt zaøídí pøekladaè pøi ukonèení 
podprogramu. </FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Pøíklad: </FONT></P>
<P><CODE>{$G+} <BR>uses crt; <BR>procedure pocitej (a,b:word;var c,d:word); 
<BR>begin <BR>&nbsp;c:=a+b;<BR>&nbsp;d:=a-b; <BR>end; <BR><BR>var 
a_,b_,c_,d_:word; <BR>begin <BR>&nbsp;a_:=40;<BR>&nbsp;b_:=5; <BR>&nbsp;clrscr; 
<BR>&nbsp;asm <BR>&nbsp;&nbsp;</CODE><CODE><STRONG>PUSH</STRONG></CODE><CODE> a_ 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{proceduøe posíláme hodnotu a_} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>PUSH</STRONG></CODE><CODE> 
b_&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;{proceduøe posíláme hodnotu 
b_}<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>LEA</STRONG></CODE><CODE> 
DI,c_&nbsp;&nbsp; &nbsp;{zjistíme adresu promìnné c_} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>PUSH</STRONG></CODE><CODE> DS 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{do zásobníku segment adresy c_} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>PUSH</STRONG></CODE><CODE> 
DI&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;{do zásobníku offset adresy 
c_}<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>LEA</STRONG></CODE><CODE> DI,d_ 
&nbsp;&nbsp;&nbsp;{to samé pro d_} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>PUSH</STRONG></CODE><CODE> 
DS&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;{stejnı segment} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>PUSH</STRONG></CODE><CODE> 
DI&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;{offset d_} 
<BR>&nbsp;&nbsp;</CODE><CODE><STRONG>CALL</STRONG></CODE><CODE> pocitej {a 
zavoláme poèítej} <BR>&nbsp;end; <BR>&nbsp;writeln 
(a_,'+(-)',b_,'=',c_,'(',d_,')'); <BR>&nbsp;readkey; <BR>end. </CODE></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Stejnou posloupnost instrukcí 
jako blok asm v tomto programu provede øádek poèítej (a_,b_,c_,d_); </FONT></P>
<H4><FONT size=-1 face="Arial CE, Arial, Helvetica">Návrat hodnoty z funkce 
</FONT></H4>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Funkce je podprogram, kterı 
vrací jednu hodnotu typu uvedeného v záhlaví. Vracenou hodnotu zjistíme po 
návratu z funkce vdy v registrech: </FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">AL - funkèní hodnota o 
  velikosti slabiky</FONT> 
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">AX - funkèní hodnota o 
  velikosti slova</FONT> 
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">DX, AX - funkèní hodnota o 
  velikosti dvojslova (u ukazatele DX - segment, AX - offset)</FONT> 
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">DX, BX, AX - funkèní 
  hodnota typu real </FONT></LI></UL>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Pokud funkce vrací øetìzec, 
musí bıt volána i s adresou místa, kam má vıslednı øetìzec zapsat. </FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Pøíklad: </FONT></P>
<P><CODE>{$G+} <BR>uses crt; <BR>function bez1 (a:word):word; <BR>begin 
<BR>&nbsp;bez1:=a-1; <BR>end; </CODE></P>
<P><CODE>var a_,c_:word; <BR>begin <BR>&nbsp;a_:=40; <BR>&nbsp;clrscr; 
<BR>&nbsp;asm <BR>&nbsp;&nbsp;<STRONG>PUSH</STRONG> a_ &nbsp;&nbsp;{posíláme 
hodnotu a_} <BR>&nbsp;&nbsp;<STRONG>CALL</STRONG> bez1 {zavoláme } 
<BR>&nbsp;&nbsp;<STRONG>MOV</STRONG> c_,AX {slovo si vyzvedneme v registru AX} 
<BR>&nbsp;end; <BR>&nbsp;writeln (a_,'-1=',c_); <BR>&nbsp;readkey; <BR>end. 
</CODE></P>
<H3><A name="Tvorba podprogramù"><FONT 
face="Arial CE, Arial, Helvetica"></FONT></A><FONT size=3 face=Arial>Tvorba 
podprogramù </FONT></H3>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Bloky programu, které 
vykonávají èinnost èasto se opakující, nazveme podprogramem. Jejich pouitím 
zjednodušíme program. Za podprogramy pokládáme procedury a funkce. Pascal 
umoòuje vkládat assembler i do obyèejnıch podprogramù. Mùeme také tvoøit 
podprogramy pouze v assembleru. To vyjádøíme zápisem assembler za definici 
procedury nebo funkce. Ty potom neobsahují klasické vymezení bloku begin...end, 
staèí jen assemblerovské asm..end (pokud tedy tvoøíme podprogram jen v 
assembleru, uvedeme za definici oznaèení assembler, blok vymezíme asm...end). S 
parametry pracujeme v podprogramech v souladu s tím, jak jsme je pøes zásobník 
pøedávali. To znamená, e k parametrùm volanım hodnotou pøistupujeme jako ke 
klasickım promìnnım, k parametrùm volanım odkazem pøistupujeme jako k ukazatelùm 
(dosazujeme jejich adresu instrukcí <STRONG>LES</STRONG>, <STRONG>LDS</STRONG>). 
</FONT></P>
<H4><FONT size=-1 face="Arial CE, Arial, Helvetica">Lokální promìnné 
</FONT></H4>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">V okamiku vstupu do 
podprogramu se na vrcholu zásobníku automaticky vytvoøí místa pro lokální 
promìnné definované v èásti var podprogramu. V pøípadì, e se jedná o 
pascalovskou funkci (není oznaèena slovem assembler v definici), je navíc 
vloena speciální promìnná @RESULT urèená k pøedání funkèní hodnoty (ta je i 
stejného datového typu). Pøed návratem z funkce je obsah promìnné @RESULT 
automaticky pøedán do registrù pøedepsanıch pro návrat hodnoty (pokud tedy 
tvoøíme funkci s vloenım assemblerovskım blokem, pøedáme funkèní hodnotu do 
promìnné @RESULT, ve funkci s oznaèením assembler vracíme funkèní hodnotu v 
registrech, ve kterıch funkèní hodnotu oèekává volající (AL, AX,..), jak bylo 
uvedeno v èásti o volání podprogramù). Lokální promìnné pouíváme stejnì jako 
globální (s tím rozdílem, e jejich segmentová adresa není v DS). </FONT></P>
<H4><FONT size=-1 face="Arial CE, Arial, Helvetica">Vıznam registru BP 
</FONT></H4>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Registr BP je v dobì 
vykonávání podprogramu nasmìrován na vrcholek zásobníku v okamiku vstupu do 
nìj. Proto pouitím nepøímé bázové adresace s pomocí tohoto registru mùeme 
pøistupovat k:</FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">parametrùm - pøíèítáním k 
  hodnotì v BP (napø. [BP + 6] je oznaèení pro pøístup k parametru) </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">lokálním promìnnım - 
  odeèítáním od hodnoty v BP (napø. [BP - 2] je oznaèení pøístupu k prvnímu 
  parametru typu word) </FONT></LI></UL>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Vzhledem k tomu, e se o tyto 
pøepoèty adres mùe postarat pøekladaè, je jednodušší pouívat pro pøístupy k 
promìnnım a parametrùm jen jejich symboly uvedené v definici podprogramu nebo 
èásti var. </FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Pøíklad: </FONT></P>
<P><CODE>uses crt; <BR>procedure pocitej (a,b:word;var c,d:word);assembler; 
<BR>asm <BR>&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> AX,a 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{do registru ax, vlo hodnotu a} 
<BR>&nbsp;</CODE><CODE><STRONG>ADD</STRONG></CODE><CODE> AX,b 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{pøièti b} 
<BR>&nbsp;</CODE><CODE><STRONG>LES</STRONG></CODE><CODE> DI,c 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{do ES:DI vlo adresu c (to je vıstup 
souètu)} <BR>&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> ES:[DI],AX {na 
adresu ES:DI zapiš souèet} 
<BR>&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> 
AX,a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {to samé pro rozdíl} 
<BR>&nbsp;</CODE><CODE><STRONG>SUB</STRONG></CODE><CODE> AX,b 
<BR>&nbsp;</CODE><CODE><STRONG>LES</STRONG></CODE><CODE> DI,d 
<BR>&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> ES:[DI],AX {a na adresu 
d zapiš rozdíl} <BR>end; <BR><BR>function bez1 (a:word):word;assembler; <BR>asm 
<BR>&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> AX,a 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{do AX vlo hodnotu parametru a} 
<BR>&nbsp;</CODE><CODE><STRONG>DEC</STRONG></CODE><CODE> AX 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{kdyby to nebyla èistì 
assemblerovská funkce, tak} 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{pøidám 
øádek:} 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> 
@RESULT, AX fce hodnotu pak také vrátí v AX} <BR>end; </CODE></P>
<P><CODE>var a_,b_,c_,d_:word; {hlavní program} <BR>begin 
<BR>&nbsp;a_:=40;b_:=5; <BR>&nbsp;clrscr; <BR>&nbsp;pocitej (a_,b_,c_,d_); 
<BR>&nbsp;writeln (a_,'+(-)',b_,'=',c_,'(',d_,')'); <BR>&nbsp;c:=bez1 (a_); 
<BR>&nbsp;writeln (a_,'-1=',c_); <BR>&nbsp;readkey; <BR>end. </CODE></P>
<H3><A name=Pøerušení><FONT face="Arial CE, Arial, Helvetica"></FONT></A><FONT 
size=3 face=Arial>Pøerušení </FONT></H3>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">V dobì vykonávání úlohy musí 
bıt zajištìna i programová obsluha nìkterıch událostí. Za tyto události 
povaujeme napøíklad: stisk klávesy, pohyb myší, hrozící vıpadek napájení, 
kritická chyba v pamìti, . . . I kdy by bylo moné testovat stisk klávesy v 
rámci provádìné úlohy, je pohodlnìjší, jestlie obsluhu této události zajistí 
poèítaè sám na úrovni technického vybavení. Pøesto je k této èinnosti nutnı 
mikroprocesor. Proto je doèasnì pøerušena probíhající úloha. Po obsluze se 
procesor vrací zpìt k té èásti úlohy, ze které byl pøerušen. </FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Celı mechanismus pøerušení se 
dá popsat v nìkolika krocích: </FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">Do øadièe pøerušení 
  pøichází poadavek o pøerušení, ten vyhodnotí jeho prioritu. Jestlie je 
  pøerušení moné, je vyslán do procesoru signál poadavku o pøerušení. </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">Mikroprocesor pøijal 
  signál poadavku pøerušení. Jestlie je pøerušení moné (není zakázáno 
  nastavením IF = 0), po dokonèení probíhající instrukce vyšle procesor signál 
  potvrzení pøerušení. </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">Øadiè pøerušení pøijal 
  signál povolení pøerušení. Vyšle na datovou sbìrnici instrukci pøerušení 
  <STRONG>INT</STRONG> èíslo, ta zajistí, e procesor provede tyto èinnosti: 
  </FONT>
  <UL>
    <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">do zásobníku se uloí 
    registr pøíznakù F (po návratu se musí obnovit) </FONT>
    <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">vynulují se pøíznaky IF 
    (zakáe se další pøerušení) a TF (nejde krokovat program) </FONT>
    <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">do zásobníku se uloí 
    obsahy CS a IP (místo, kde byla pøerušovaná úloha) </FONT>
    <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">registry CS a IP se 
    naplní adresou, pøeètenou z tabulky vektorù pøerušení (to je tabulka na 
    zaèátku pamìti, v ní jsou za sebou uloeny celé adresy všech obsluh 
    pøerušení, klíèem pro hledání v této tabulce je právì èíslo pøerušení 
    uvedené za instrukcí INT) </FONT></LI></UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">Probìhne obsluha pøerušení 
  (napøíklad naètení dat, hláška na obrazovku,...). </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">Po obsluze je ze zásobníku 
  obnoven obsah registrù IP, CS, F (procesor se vrátí k pùvodní úloze, pøíznaky 
  TF, IF se obnoví s registrem F). Obnovu tìchto registrù zajistí instrukce 
  <STRONG>IRET</STRONG> (která je na konci obsluhy pøerušení). </FONT></LI></UL>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Za instrukcí 
<STRONG>INT</STRONG> mùe bıt èíslo v rozpìtí 0..255. Toto èíslo v pøípadì 
obsluhy programové události udává, odkud poadavek pøišel. Protoe je ale 
nemoné, aby všech 256 úrovní pøerušení bylo obsazeno, jsou nìkteré hodnoty 
obsazeny tzv. slubami. </FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Za sluby mùeme povaovat 
podprogramy, které jsou souèástí operaèního systému nebo BIOSu. Jsou umístìny v 
pamìti poèítaèe. Umoòují jednoduše provádìt èinnosti, které se v programech 
èasto opakují, jsou pracné nebo se liší na poèítaèích s rùznou konfigurací. 
</FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Sluby voláme stejnì jako 
obsluhy pøerušení instrukcí <STRONG>INT</STRONG> èíslo. Hodnota èíslo urèuje, o 
jakou slubu se jedná. Èasto se v rámci jedné sluby mùe vyskytovat i nìkolik 
èinností. Tìm budeme øíkat podsluby. Pøed voláním podslueb musíme napøed 
nastavit v urèitém registru (nejèastìji v AH) hodnotu jim urèenou. Potom teprve 
voláme slubu instrukcí <STRONG>INT</STRONG>. Mnoho slueb se chová jako 
podprogramy volané parametry. Hodnoty parametrù se neukládají do zásobníku, ale 
do nìkterıch registrù. Vıstupy z tìchto "podprogramù" najdeme opìt v registrech. 
Informace o slubách DOSu i BIOSu najdete v odbornıch publikacích nebo v 
SYSMANu. Zde také najdete informace o tom, které registry k èemu pouijete. 
</FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Nejpouívanìjší slubou je 
<STRONG>INT</STRONG> $21. Ta zahrnuje sluby DOSu jako je vstup a vıstup dat, 
práce se soubory, èas, . . . Je také pouita k vıstupu pascalovského øetìzce na 
obrazovku v následujícím pøíkladu. Vıstup øetìzce realizuje podsluba AH = $9. 
Vstupem do podsluby je adresa øetìzce v registrech DS, DX. Vıstup podsluba 
nemá. Jediná èinnost je vıpis na obrazovku. Dùleité je oznaèení konce øetìzce 
znakem $. V pøípadì, e tento znak na konci není, vypíše se obsah èásti pamìti 
a do jeho náhodného vıskytu. </FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Pøíklad: </FONT></P>
<P><CODE>procedure outstring (retezec:string);assembler; <BR>asm 
<BR>&nbsp;</CODE><CODE><STRONG>PUSH</STRONG></CODE><CODE> DS&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;{ulo DS, budeme ho mìnit} 
<BR>&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> 
AH,$09&nbsp;&nbsp;&nbsp;&nbsp; {nastav hodnotu podsluby} 
<BR>&nbsp;</CODE><CODE><STRONG>LDS</STRONG></CODE><CODE> DI,retezec {èti adresu 
øetìzce} <BR>&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> DX,DI 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{vlo ji do registru DX pro podslubu} 
<BR>&nbsp;</CODE><CODE><STRONG>INC</STRONG></CODE><CODE> DX 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{zvyš adresu a za informaci o 
délce} <BR>&nbsp;</CODE><CODE><STRONG>XOR</STRONG></CODE><CODE> BH,BH 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{nuluj BH} 
<BR>&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> BL,[DI] 
&nbsp;&nbsp;&nbsp;{do BL vlo délku øetìzce} 
<BR>&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> 
</CODE><CODE><STRONG>BYTE</STRONG></CODE><CODE> 
</CODE><CODE><STRONG>PTR</STRONG></CODE><CODE> [DI+BX+1],'$'{na konec øetìzce 
dosaï ukonèovací znak} <BR>&nbsp;</CODE><CODE><STRONG>INT</STRONG></CODE><CODE> 
$21 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{volej sluby DOSu} 
<BR>&nbsp;</CODE><CODE><STRONG>POP</STRONG></CODE><CODE> DS 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{vra DS} <BR>end; <BR><BR>begin 
<BR>&nbsp;outstring ('Ahoj'); {zkus vypsat} <BR>end. </CODE></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Uvedenı program pøevede 
pascalovskı øetìzec do podoby øetìzce, ve které ho oèekává sluba. Nastaví 
registry hodnotami vstupù a zavolá podslubu DOSu. Vıstup øetìzce touto 
procedurou mùeme realizovat na libovolném grafickém adaptéru. Moné odlišnosti 
si vyøeší právì sluba DOS. </FONT></P>
<H3><A name="Rezidentní programy"><FONT 
face="Arial CE, Arial, Helvetica"></FONT></A><FONT size=3 face=Arial>Rezidentní 
programy </FONT></H3>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Velká skupina programù je 
schopna pracovat na pozadí provádìné úlohy. Patøí mezi nì ovladaèe (myši, 
klávesnice, . . .), utility (hodiny, antivirová kontrola, stahovaèe obrazovek, . 
. .), viry (bez komentáøe). Tìmto programùm pøidáváme oznaèení rezidentní. 
</FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Jejich základní vlastností je 
jejich neustálá pøítomnost v pamìti poèítaèe a schopnost se vyvolat, jestlie je 
to nutné. Z toho vyplıvají i poadavky na nì: malá délka kódu (musí obsadit co 
nejménì pamìti) a nezávislost na spuštìnıch aplikacích. </FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Èinnost tìchto programù na 
pozadí aplikací zaruèuje jejich volání spolu s obsluhami pøerušení. Jestlie 
tedy dojde k nìjaké události (stisk klávesy, pøijetí dat na port, uplynutí 
urèité doby, . . .), je voláno pøerušení obsluhující tuto událost. Po této 
obsluze (,nebo pøed ní) probìhne i èást rezidentního programu pøipojeného k ní. 
Aby k tomu došlo, musí tvùrce rezidentního programu zmìnit adresu v tabulce 
vektorù pøerušení na adresu svého podprogramu. Pøitom si starou adresu obsluhy 
uschová, aby mohl zajistit volání pùvodní obsluhy události. Je jen na tvùrci, 
jestli starou obsluhu bude volat nebo ne (jestlie ji ale nezavolá, mohou se 
vyskytnout problémy). Programátor se také mùe rozhodnout, ve které èásti svého 
programu bude obsluhu volat (napø. nemohu èíst jaká klávesa byla stisknuta, kdy 
ještì neprobìhla obsluha klávesnice). Rezidentní program má tyto èásti: 
</FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">podprogramy, které jsou 
  volány s pøerušením (za jejich hlavièkou následuje slovo interrupt) 
  vykonávající uiteènou nebo záškodnickou èinnost; ty navíc mohou volat pùvodní 
  obsluhy (posloupností instrukcí PUSHF, CALL adresa staré obsluhy) </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">hlavní program, kterı má 
  za úkol: </FONT>
  <UL>
    <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">pøeètení adresy pùvodní 
    obsluhy pøerušení a její uloení do promìnné (typu procedure); to zajistí 
    procedura z knihovny DOS: </FONT><CODE>GetIntVec (èíslo pøerušení, adresa 
    promìnné typu procedure) </CODE>
    <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">zmìna pùvodní adresy na 
    adresu našeho podprogramu; to zajistí procedura z knihovny DOS: 
    </FONT><CODE>SetIntVec (èíslo pøerušení, adresa našeho podprogramu) </CODE>
    <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">ohlášení instalace 
    (napø. </FONT><CODE>Writeln ('Rezidentní program instalován.');</CODE><FONT 
    size=2 face=Arial>) </FONT>
    <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">ukonèení programu s tím, 
    e zùstane v pamìti; to zajistí procedura </FONT><CODE>Keep (0) 
  </CODE></LI></UL></LI></UL>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">V Pascalu musíme navíc v 
rezidentním programu ohranièit podprogramy interrupt direktivou {$F+}, která 
zajistí, e bude uvnitø pouito vzdálené volání (za podprogram napíšeme {$F-} 
pro návrat do automatického zjišování vzdálenıch adres). Navíc musíme zajistit 
správnou alokaci pamìti pro rezidentní program oznaèením v úvodu programu {$M 
400,0,0}, které vymezí oblast rezervovanou pro zásobník atd. (hodnoty je 
nejlepší vyzkoušet). </FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Nejèastìji se pro rezidentní 
programy pouívají pøerušení: </FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">$1C - volané 18,2krát za 
  vteøinu </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">$09 - volané po události 
  na klávesnici (stisk klávesy) </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">$28 - volané v pøípadì, e 
  mikroprocesor není zatíenı (èeká . . .) </FONT></LI></UL>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Ostatní hodnoty pøerušení se 
dají zjistit z literatury (nebo SYSMANu). </FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Na jaké pøerušení rezident 
pøipojíme, závisí do znaèné míry na tom, co má dìlat a na co má reagovat. Obèas 
je dobré si v obsluze jednoho pøerušení nastavit promìnné a v závislosti na 
jejich stavu vykonat (nebo nevykonat) urèitou èinnost v obsluze jiného 
pøerušení. Èasto si ani neuvìdomíme, e náš podprogram pøipojenı k urèitému 
pøerušení, ho nepøímo volá. Dojde tak k zacyklení. Toho se èásteènì vyvarujeme 
tím, e veškeré èinnosti, spojené se vstupy a vıstupy, provádíme sami a nevoláme 
pascalovské procedury (napø. vıstup na obrazovku realizujeme pøímım zápisem do 
VRAM, pouití writeln vede k chybì). </FONT></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Pøíklad: </FONT></P>
<P><CODE>{$M $400,0,0} 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{nastav pamì: 
zásobník $400 slabik} <BR>uses Dos; <BR>var IntVec : Procedure; {promìnná pro 
adresu staré obsluhy} </CODE></P>
<P><CODE>{$F+} 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{vzdálená 
volání} <BR>procedure hodiny;interrupt;assembler; {nová obsluha pøerušení} 
<BR>asm <BR>&nbsp;</CODE><CODE><STRONG>JMP</STRONG></CODE><CODE> @zac 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{pøeskoè 
data} <BR>@vid: <BR>&nbsp;</CODE><CODE><STRONG>DW</STRONG></CODE><CODE> 
156,$B800 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{adresa 
místa VRAM, kde budou hodiny} <BR>@zac: 
<BR>&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> CL,2 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{hodiny, 
minuty, vteøiny (cyklus)} <BR>@c1 : 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{zaèátek 
cyklu} <BR>&nbsp;</CODE><CODE><STRONG>LES</STRONG></CODE><CODE> 
BX,CS:[</CODE><CODE><STRONG>OFFSET</STRONG></CODE><CODE> @vid]{naber adresu 
promìnné slovo do BX} <BR>&nbsp;</CODE><CODE><STRONG>XOR</STRONG></CODE><CODE> 
AH,AH 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{vyma 
horní polovinu registru AX} 
<BR>&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> AL,CL 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{naber 
do dolní poloviny AX krok i} 
<BR>&nbsp;</CODE><CODE><STRONG>SHL</STRONG></CODE><CODE> AL,1 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{vynásob, 
AL:=AL*2} <BR>&nbsp;</CODE><CODE><STRONG>SUB</STRONG></CODE><CODE> BX,AX 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{odeèti 
od BX obsah AX} <BR>&nbsp;</CODE><CODE><STRONG>OUT</STRONG></CODE><CODE> $70,AL 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{pošli 
na CMOS adresu ètené slabiky} 
<BR>&nbsp;</CODE><CODE><STRONG>SHL</STRONG></CODE><CODE> AL,1 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{vynásob, 
AL:=AL*2} <BR>&nbsp;</CODE><CODE><STRONG>SUB</STRONG></CODE><CODE> BX,AX 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{odeèti, 
to ovlivní tvaru vıstupu} 
<BR>&nbsp;</CODE><CODE><STRONG>IN</STRONG></CODE><CODE> AL,$71 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{pøeèti 
z CMOS obsah ètené slabiky} 
<BR>&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> DL,AL 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{zkopíruj 
obsah této slabiky do AH} 
<BR>&nbsp;</CODE><CODE><STRONG>SHR</STRONG></CODE><CODE> DL,4 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{desítky 
posuò do dolní poloviny AH} 
<BR>&nbsp;</CODE><CODE><STRONG>AND</STRONG></CODE><CODE> AX,$F 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{odstraò 
zbyteèné bity} <BR>&nbsp;</CODE><CODE><STRONG>AND</STRONG></CODE><CODE> DX,$F 
<BR>&nbsp;</CODE><CODE><STRONG>OR</STRONG></CODE><CODE> AX,$1F30 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{proveï pøevod 
do ASCII, pøidej atr.} <BR>&nbsp;</CODE><CODE><STRONG>OR</STRONG></CODE><CODE> 
DX,$1F30 </CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> ES:2[BX],AX {nastav 
jednotky ve VRAM} <BR>&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> 
ES:[BX],DX &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{nastav desítky ve 
VRAM} <BR>&nbsp;</CODE><CODE><STRONG>DEC</STRONG></CODE><CODE> CL 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{sníit 
CL} <BR>&nbsp;</CODE><CODE><STRONG>JNS</STRONG></CODE><CODE> @c1 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{konec 
cyklu} <BR>&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> 
</CODE><CODE><STRONG>WORD</STRONG></CODE><CODE> 
</CODE><CODE><STRONG>PTR</STRONG></CODE><CODE> ES:[154],$1F00+'.'{ve VRAM oddìl 
vteøiny a minuty} <BR>&nbsp;</CODE><CODE><STRONG>MOV</STRONG></CODE><CODE> 
</CODE><CODE><STRONG>WORD</STRONG></CODE><CODE> 
</CODE><CODE><STRONG>PTR</STRONG></CODE><CODE> ES:[148],$1F00+'.'{ve VRAM oddìl 
minuty a hodiny} <BR>&nbsp;</CODE><CODE><STRONG>PUSHF</STRONG></CODE><CODE> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{do 
zásobníku registr pøíznakù} 
<BR>&nbsp;</CODE><CODE><STRONG>CALL</STRONG></CODE><CODE> IntVec 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{volej starou 
obsluhu $1C} <BR>end; <BR>{$F-} 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{konec 
vzdálenıch volání} </CODE></P>
<P><CODE>begin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{hlavní 
program} <BR>&nbsp;GetIntVec($1c,@IntVec);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{èti 
adresu staré obsluhy} <BR>&nbsp;SetIntVec($1c,Addr(hodiny));{na její místo dej 
adresu mojí obsluhy} <BR>&nbsp;Writeln('Rezidentní hodiny 
instalovány.');{informuj o instalaci} <BR>&nbsp;Keep 
(0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ukonèi 
s tím, e zùstane program v pamìti} <BR>end. </CODE></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">Uvedenı program ète pøi 
obsluze pøerušení $1C stav hodin z pamìti CMOS. Po pøepoètu adres a úpravì znakù 
z BCD kódu do ASCII je informace o èase zobrazena v pravém horním rohu 
obrazovky. Hlavní program má za úkol jen zmìnu adresy pùvodní obsluhy na naší. 
</FONT></P>
<P><A name=Literatura:><FONT size=-1 
face="Arial CE, Arial, Helvetica"></FONT></A><FONT size=2 face=Arial>Literatura: 
</FONT></P>
<UL>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">Michal Brandejs: 
  Mikroprocesory INTEL 8086-80486, Grada 1991 </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">Tomáš Novák: Turbo Pascal 
  6 - Popis jazyka, Grada 1991 </FONT>
  <LI><FONT size=-1 face="Arial CE, Arial, Helvetica">Pavel Mikula, Kateøina 
  Juhová, Jiøí Soukenka: Borland Pascal 7.0, Kompendium, Grada 1994 
</FONT></LI></UL>
<DIV align=right>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica">© 1996-1997 <A 
onmouseover="window.status='Napište mi na forwardovanou adresu: papousekt@usa.net'; return true" 
onmouseout="window.status=''; return true" href="mailto:papousekt@usa.net">Mgr. 
Tomáš Papoušek</A></FONT></P>
<P></P></DIV>
<P></P>
<P><FONT size=-1 face="Arial CE, Arial, Helvetica"><B>Tento text je moné 
pouívat pro studijní úèely bez omezení. V pøípadì komerèního vyuití 
kontaktujte autora.</B></FONT></P></BODY></HTML>
